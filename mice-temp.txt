n_zero with n_above_zero



üé¨ Import [surfaceome_hspc.csv](data-raw/surfaceome_hspc.csv) and xxxxxxxx

```{r}
# üê≠ import the hspc data
hspc <- read_csv("data-raw/surfaceome_hspc.csv")
```




üé¨ Pivot the expression values (stack the columns) so all the counts are
in a single column (`expr`) and pipe into `ggplot()` to create a
histogram:

```{r}
hspc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |> 
  ggplot(aes(x = expr)) +
  geom_histogram()
```

This is a very striking distribution. Is it what we are expecting?
Again,the excess number of low values is almost certainly anomalous.
They will be inaccurate measure and we will want to exclude expression
values below (about) 1. We will revisit this after we have considered
the distribution of expression across cells and genes.

What about the bimodal appearance of the the 'real' values? If we had
the whole genome we would not expect to see such a pattern - we'd expect
to see a roughly normal distribution[^1]. However, this is a subset of
the genome and the nature of the subsetting has had an influence here.
These are a subset of cell surface proteins that show a significant
difference between at least two of twelve cell subtypes. That is, all of
these genes are either high or low.


#### üê≠ Mouse cells

We used the `summary()` function to get an overview of the columns in
the frog data. Let's try that here.

üé¨ Get a quick overview of the columns:

```{r}
#| class: outputscroll
summary(hspc)
```

Hmmmm, did you get all that? Nope, me neither! We have 701 cells but we
only have 6 samples for the frogs. We will need a different approach to
get an overview but I find it is still useful to look at the few columns

üé¨ Get a quick overview the first 20 columns:

```{r}
#| class: outputscroll
summary(hspc[1:20])
```

Notice that:

-   the maximum value is much less high than for the frogs and has
    decimals. That is because the mouse data are logged (to base 2)
    normalised counts, not raw counts as they are in the frog data set.
-   a minimum value of 0 appears in all 20 columns - perhaps that is
    true across the whole dataset (or at least common)
-   at least some of the medians are zeros so there must be quite a lot
    of zeros
-   the few columns we can see are roughly similar
-   it would not be very practical to plot the distributions of values
    in cell cell using `facet_wrap()`.

In this data set, there is even more of an advantage of using the
`pivot_longer()`, `group_by()` and `summarise()` approach. We will be
able to open the dataframe in the Viewer and make plots to examine
whether the distributions are similar across cells.

üé¨ Summarise all the cells:

```{r}
hspc_summary_samp <- hspc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(cell) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            mean = mean(expr),
            median = median(expr),
            sd = sd(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            n_zero = sum(expr == 0))
```

Notice that I have used `cell` as the column name rather than `sample`
and `expr` (expression) rather than `count`. I've also added the
standard deviation.

üé¨ View the `hspc_summary_samp` dataframe (click on it in the
environment).

All cells have quite a few zeros and the lower quartile is 0 for all
cells, *i.e.*, every cell has many genes with zero expression.

To get a better understanding of the distribution of expressions in
cells we can create a ggplot using the pointrange geom. Pointrange puts
a dot at the mean and a line between a minimum and a maximum such as +/-
one s.d. Not unlike a boxplot, but when you need the boxes too be very
narrow!

üé¨ Create a pointrange plot.

```{r}
hspc_summary_samp |> 
  ggplot(aes(x = cell, y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, 
                      ymax = mean + sd ),
                  size = 0.1)
```

You will need to use the Zoom button to pop the plot window out so you
can make it as wide as possible

The things to notice are:

-   the average expression in cells is similar for all cells. This is
    good to know - if some cells had much lower expression perhaps there
    is something wrong with them, or their sequencing, and they should
    be excluded.
-   the distributions are roughly similar in width too

The default order of `cell` is alphabetical. It can be easier to see
these (non-) effects if we order the lines by the size of the mean.

üé¨ Order a pointrange plot with `reorder(variable_to_order, order_by)`.

```{r}
hspc_summary_samp |> 
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, 
                      ymax = mean + sd ),
                  size = 0.1)
```

`reorder()` arranges `cell` in increasing size of `mean`

üé¨ Write `hspc_summary_samp` to a file called "hspc_summary_samp.csv":

```{r}
#| echo: false
write_csv(hspc_summary_samp, 
          file = "data-processed/hspc_summary_samp.csv")
```


There are fewer genes in this dataset, but still more than you can
understand without the overview provided by a plot. We will again pivot
the data to tidy and then summarise the expression for each gene.

üé¨ Summarise the expression for each genes:

```{r}
hspc_summary_gene <- hspc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(ensembl_gene_id) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_zero = sum(expr == 0))
```

üé¨ View the `hspc_summary_gene` dataframe. Remember these are normalised
and logged (base 2) so we should not see very large values.

Notice that we have:

-   no genes with 0 in every cell
-   very few genes (9) with no zeros at all
-   quite a few genes with zero in many cells but this matters less than
    zeros in the frog samples because we had just 6 samples and we have
    701 cells.

As we have a lot of genes, it is again helpful to plot the mean
expression with pointrange to get an overview. We do not need to log the
values but ordering the genes will help.

üé¨ Plot the logged mean counts for each gene in order of size using
`geom_pointrange()`:

```{r}
hspc_summary_gene |> 
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, 
                      ymax = mean + sd),
                  size = 0.1)
```

Note again that the variability between genes (average expression
between 0.02 and and 10.03) is far greater than between cells (average
expression from1.46 to 3.18) which is expected.

üé¨ Write `s30_summary_gene` to a file called "s30_summary_gene.csv":

```{r}
#| echo: false
write_csv(hspc_summary_gene, 
          file = "data-processed/hspc_summary_gene.csv")
```




# üê≠ Analysis

We will carry out several steps

1.  Import the prog and hspc data
2.  Combine the two datasets ready for analysis
3.  Filter the data to remove genes that are not expressed in any cell
4.  Find the genes that are expressed in only one cell type (the prog or
    the hspc)
5.  Do differential expression analysis on the genes using the
    **`scran`** package. This needs to be done on the logged normalised
    counts.

## Import

üé¨ Import surfaceome_hspc.csv and surfaceome_prog.csv into dataframes
called `hspc` and `prog` respectively.

```{r}
#| echo: false
#---CODING ANSWER---
hspc <- read_csv("data-raw/surfaceome_hspc.csv")
prog <- read_csv("data-raw/surfaceome_prog.csv")
```

## Combine the two datasets

We need to combine the two datasets of 701 and 798 cells into one
dataset of 1499 cells, i.e., 1499 columns. The number of rows is the
number of genes, 280. Before combining, we must make sure genes in the
same order in both dataframes or we would be comparing the expression of
one gene in one cell type to the expression of a different gene in the
other cell type!

üé¨ Check the gene ids are in the same order in both dataframes:

```{r}
identical(prog$ensembl_gene_id, hspc$ensembl_gene_id)
```

**`scran`** can use a matrix or a dataframe of counts but theses must be
log normalised counts. If using a dataframe, the columns must only
contain the expression values (not the gene ids).

üé¨ Combine the two dataframes (minus the gene ids) into one dataframe
called `prog_hspc`:

```{r}
prog_hspc <- bind_cols(prog[-1], hspc[-1])

```

üé¨ Now add the gene ids as the row names:

```{r}
row.names(prog_hspc) <- prog$ensembl_gene_id
```

## Filter to remove unexpressed genes

In this dataset, we will not see and genes that are not expressed in any
of the cells because we are using a specific subset of the transcriptome
that was deliberately selected. However, we will go through how to do
this because it is an important step in most analyses.

For the üê∏ frog data you should remember that we were able to filter out
our unexpressed genes in [Transcripttranscriptomics 1](../week-3/workshop.html) because we
were examining both groups to be compared. In that workshop, [we
discussed](../week-3/workshop.html#frog-filtering) that we could not
filter out unexpressed genes in the üê≠ mouse data because we only had
one cell types at that time. During the [Consolidate Independent
Study](../week-3/study_after_workshop.html) you examined the hspc cells.

Where the sum of all the values in the rows is zero, all the entries
must be zero. We can use this to find the filter the genes that are not
expressed in any of the cells. To do row wise aggregates such as the sum
across rows we can use the `rowwise()` function. `c_across()` allows us
to use the colon notation `Prog_001:HSPC_852` in `sum()` rather than
having to list all the column names:
`sum(Prog_001, Prog_002, Prog_002, Prog_004,.....)`

üé¨ Find the genes that are 0 in every column of the prog_hspc dataframe:

```{r}
prog_hspc |> 
  rowwise() |> 
  filter(sum(c_across(Prog_001:HSPC_852)) == 0)

```

Notice that we have summed across all the columns.

‚ùì What do you conclude?

<!-- #---THINKING ANSWER--- -->

<!-- The are no genes that are completely unexpressed in this set of 280 genes -->

We might also examine the genes which are least expressed.

üé¨ Find ten least expressed genes:

```{r}
rowSums(prog_hspc) |> sort() |> head(10)
```

‚ùì What do you conclude?

<!-- #---THINKING ANSWER--- -->

<!-- When you consider that there are 1499 cells, a values of 30 are low even  -->

<!-- considering these are already logged and normalised (ie., the range of  -->

<!-- values is less that it would be for raw counts) -->

## Find the genes that are expressed in only one cell type

To find the genes that are expressed in only one cell type, we can use
the same approach as above but only sum the columns for one cell type.

üé¨ Find the genes that are 0 in every column for the HSPC cells:

```{r}
prog_hspc |> 
  rowwise() |> 
  filter(sum(c_across(HSPC_001:HSPC_852)) == 0)

```

We have summed across the HSPC cells only. 
Note that if we knew there were some rows that were all zero across both
cell types, we would need to add
`|> filter(sum(c_across(Prog_001:Prog_852)) != 0)`

meaning zero in all the HSPC but not zero in all the Prog

üé¨ Now you find the genes that are 0 in every column for the Prog cells:

```{r}
#| echo: false
#---CODING ANSWER---
prog_hspc |> 
  rowwise() |> 
  filter(sum(c_across(Prog_001:Prog_852)) == 0)

```

‚ùì What do you conclude?

<!-- #---THINKING ANSWER--- -->

<!-- there are no genes that are expressed in only one cell type -->

## Differential expression analysis

Like **`DESeq2`**, **`scran`** uses a statistical model to calculate the
significance of the difference between the treatments and needs metadata
to define the treatments.

üé¨ Load the **`scran`** package:

```{r}
#| echo: false
library(scran)
```

The meta data needed for the frog data was information about which
columns were in which treatment group and which sibling group and we had
that information in a file. Similarly, here we need information on which
columns are from which cell type. Instead of having this is a file, we
will create a vector that indicates which column belongs to which cell
type.

üé¨ Create a vector that indicates which column belongs to which cell
type:

```{r}
cell_type <- rep(c("prog","hspc"), 
                 times = c(length(prog) - 1,
                           length(hspc) - 1))
```

The number of times each cell type is repeated is the number of columns
in that cell type minus 1. This is because we have removed the column
with the gene ids. Do check that the length of the `cell_type` vector is
the same as the number of columns in the `prog_hspc` dataframe.

üé¨ Run the differential expression analysis:

```{r}
res_prog_hspc <- findMarkers(prog_hspc, 
                             cell_type)
```

`findMarkers()` is the function that runs the differential expression
analysis. The first argument is the dataframe containing the data. The
second argument is the vector indicating which columns are in which cell
type. It gives us two dataframes of the results - rather unnecessarily.
One is the results with fold changes that are Prog/HSPC and the other is
the results with fold changes that are HSPC/Prog. These have the same
magnitude, just a different sign

The dataframe `res_prog_hspc$prog` is log prog - log hspc
(i.e.,Prog/HSPC). This means - Positive fold change: prog is higher than
hspc - Negative fold change: hspc is higher than prog

The dataframe `res_prog_hspc$hspc` is log hspc - log prog (i.e.,
HSPC/Prog). . This means - Positive fold change: hspc is higher than
prog - Negative fold change: prog is higher than hspc

```{r}
#| echo: false
data.frame(res_prog_hspc$prog, 
           ensembl_gene_id = row.names(res_prog_hspc$prog)) |>
  head() |> 
  knitr::kable(cap = "The res_prog_hspc$prog dataframe")
```

```{r}
#| echo: false
data.frame(res_prog_hspc$hspc, 
           ensembl_gene_id = row.names(res_prog_hspc$hspc)) |>
  head() |> 
  knitr::kable(cap = "The res_prog_hspc$hspc dataframe. Notice the sign of the fold change is the other way")
```

## Add gene information from Ensembl using biomaRt

[Ensembl](https://www.ensembl.org/index.html) [@martin2023;
@birney2004]is a bioinformatics project to organise all the biological
information around the sequences of large genomes. The are a large
number of databases but [BioMart](https://www.ensembl.org/info/data/biomart/index.html)
[@smedley2009] provides a consistent interface to the material. There
are web-based tools to use these but the R package **`biomaRt`**
[@biomaRt] gives you programmatic access making it easier to integrate information into R dataframes

üé¨ Load the **`biomaRt`** [@biomaRt] package:

```{r}
library(biomaRt)
```

üé¨ Connect to the mouse database and see the first 20 bits of information we can retrieve:
```{r}
# Connect to the mouse database
ensembl <- useMart(biomart = "ensembl", 
                   dataset = "mmusculus_gene_ensembl")

# See what information we can retrieve
listAttributes(mart = ensembl) |> head(20)

```

There are many (2,985!) possible bits of information (attributes) that can be obtained. You can replace `head(20)` with `View()` to see them all.

We use the `getBM()` function to retrieve information from the database. The `filters` argument is used to specified what kind of identifier we are supplying to retrieve information. The `attributes` argument is used to select the information we want to retrieve. The `values` argument is used to specify the identifiers. The mart argument is used to specify the connection we created.

üé¨ Get the gene information:
```{r}
gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = prog_hspc_results$ensembl_gene_id,
                   mart = ensembl)
```

We are getting the gene name and and a description. We also need to get the id because we will use that to merge the `gene_info` dataframe with the `prog_hspc_results` dataframe. Notice the dataframe returned only has 279 rows - one of the ids does not have information.

üé¨ We can find which is missing with:

```{r}
#| error: true
# prog_hspc_results |> select(ensembl_gene_id) |> 
#   filter(!ensembl_gene_id %in% gene_info$ensembl_gene_id)

```

Oh, **`conflicted`** has flagged a conflict for us.

üé¨ Take the appropriate action to resolve the conflict:


```{r}
#| include: false
#---CODING ANSWER---
# prog_hspc_results |> dplyr::select(ensembl_gene_id) |> 
#   filter(!ensembl_gene_id %in% gene_info$ensembl_gene_id)
```
‚ùì What is the id which is missing information?

<!-- #---THINKING ANSWER--- -->
<!-- ENSMUSG00000029386	 -->


We might want to look that up - but let's worry about it later if
it turns out to be something important.

üé¨ Merge the gene information with the results:

```{r}
prog_hspc_results <- prog_hspc_results |> 
  left_join(gene_info, by = "ensembl_gene_id")
```

I recommend viewing the dataframe to see the new columns.
We now have dataframe with all the info we need, normalised counts,
log~2~ normalised counts, statistical comparisons with fold changes and p
values, information about the gene other than just the id





üé¨ Write the results to file:

```{r}
data.frame(res_prog_hspc$prog, 
           ensembl_gene_id = row.names(res_prog_hspc$prog)) |> 
  write_csv("results/prog_hspc_results.csv")
```


We need to import both the normalised counts and the statistical
results. We will need all of these for the visualisation and
interpretation.

üé¨ Import the normalised counts for the Prog and HSPC cell types. I used
the names `prog` and `hspc` for the dataframes.

```{r}
#| include: false
#---CODING ANSWER---
# import the normalised counts
prog <- read_csv("data-raw/surfaceome_prog.csv")
hspc <- read_csv("data-raw/surfaceome_hspc.csv")

```

üé¨ Combine the two dataframes (minus one set of gene ids) into one
dataframe called prog_hspc:

```{r}
# combine into one dataframe dropping one of the gene id columns
prog_hspc <- bind_cols(prog, hspc[-1])
```

üé¨ Import the statistical results in `results/prog_hspc_results.csv`. I
used the name `prog_hspc_results` for the dataframe.

```{r}
#| include: false
#---CODING ANSWER---
# import the DE results
prog_hspc_results <- read_csv("results/prog_hspc_results.csv")
```

üé¨ Remind yourself what is in the rows and columns and the structure of
the dataframe (perhaps using `glimpse()`)

```{r}
#| include: false
#---CODING ANSWER---
glimpse(prog_hspc)
```

<!-- #---THINKING ANSWER--- -->

<!-- The normalised counts dataframe has 280 rows and 1,500 columns: which are the cell id names and the gene ids. -->

```{r}
#| include: false
#---CODING ANSWER---
glimpse(prog_hspc_results)
```

<!-- #---THINKING ANSWER--- -->

<!-- the results dataframe contains the fold change and p values for each gene. -->

<!-- 280 rows and 6 columns:  -->

<!-- Top, p.value, FDR, summary.logFC, logFC.hspc, ensembl_gene_id  -->

It is useful to have this information in a single dataframe to which we
will add the gene information from Ensembl Having all the information
together will make it easier to interpret the results and select genes
of interest.

üé¨ Merge the two dataframes:

```{r}
# merge stats results with normalise values
prog_hspc_results <- prog_hspc_results |> 
  left_join(prog_hspc, by = "ensembl_gene_id")
```

This means you have the counts for each sample along with the
statistical results for each gene.


## Write the significant genes to file

We will create dateframe of the signifcant genes and write them to file. These are the files you want to examine in more detail along with the visualisations to select your genes of interest.


üé¨ Create a dataframe of the genes significant at the 0.01 level:
```{r}
prog_hspc_results_sig0.01 <- prog_hspc_results |> 
  filter(FDR <= 0.01)
```

üé¨ Write the dataframe to file

```{r}
#| include: false
#---CODING ANSWER---
write_csv(prog_hspc_results_sig0.01, 
          file = "results/prog_hspc_results_sig0.01.csv")
```

üé¨ Create a dataframe of the genes significant at the 0.05 level and write to file:
```{r}
#| include: false
#---CODING ANSWER---
prog_hspc_results_sig0.05 <- prog_hspc_results |> 
  filter(FDR <= 0.05)

# write to csv file
write_csv(prog_hspc_results_sig0.05, 
          file = "results/prog_hspc_results_sig0.05.csv")
```

‚ùìHow many genes are significant at the 0.01 and 0.05 levels?

<!-- #---THINKING ANSWER--- -->
<!-- 168 genes are significant at the 0.01 level and 182 genes are  -->
<!-- significant at the 0.05 level. -->


## View the relationship between cells using PCA

We have 280 genes in our dataset. PCA will allow us to plot our cells in the "gene expression" space so we can see if Prog cells cluster together and HSPC cells cluster together as we would expect. We do this on the log~2~ transformed normalised counts. 

Our data have genes in rows and samples in columns which is a common organisation for gene expression data. However, PCA expects cells in rows and genes, the variables, in columns. We can transpose the data to get it in the correct format.

üé¨ Transpose the log~2~ transformed normalised counts:
```{r}
prog_hspc_trans <- prog_hspc_results |> 
  dplyr::select(starts_with(c("Prog_", "HSPC_"))) |>
  t() |> 
  data.frame()
```

We have used the `select()` function to select all the columns that start with `Prog_` or  `HSPC_`. We then use the `t()` function to transpose the dataframe. We then convert the resulting matrix to a dataframe using `data.frame()`. If you view that dataframe you'll see it has default column name which we can fix using `colnames()` to set the column names to the gene ids.

üé¨ Set the column names to the gene ids:

```{r}
colnames(prog_hspc_trans) <- prog_hspc_results$ensembl_gene_id
```

perform PCA using standard functions

```{r}
pca <- prog_hspc_trans |>
  prcomp(rank. = 15) 
```

The `rank.` argument tells `prcomp()` to only calculate the first 15 principal components. This is useful for visualisation as we can only plot in 2 or 3 dimensions. We can see the results of the PCA by viewing the `summary()` of the `pca` object.


```{r}
summary(pca)
```

The Proportion of Variance tells us how much of the variance is explained by each component. We can see that the first component explains 0.1099 of the variance, the second 0.04874, and the third 0.2498. Together the first three components explain 18% of the total variance in the data. Plotting PC1 against PC2 will capture about 16% of the variance. This is not that high but it likely better than we would get plotting any two genes against each other.
To plot the PC1 against PC2 we will need to extract the PC1 and PC2
score from the pca object and add labels for the cells.


üé¨ Create a dataframe of the PC1 and PC2 scores which are in `pca$x` and add the cell ids:
```{r}
pca_labelled <- data.frame(pca$x,
                           cell_id = row.names(prog_hspc_trans))
```

It will be helpful to add a column for the cell type so we can label points. One way to do this is to extract the information in the cell_id column into two columns. 

üé¨ Extract the cell type and cell number from the `cell_id` column (keeping the `cell_id` column):
```{r}
pca_labelled <- pca_labelled |> 
  extract(cell_id, 
          remove = FALSE,
          c("cell_type", "cell_number"),
          "([a-zA-Z]{4})_([0-9]{3})")
```

`"([a-zA-Z]{4})_([0-9]{3})"` is a [regular expression](https://en.wikipedia.org/wiki/Regular_expression) - or regex. `[a-zA-Z]` means any lower or upper case letter, `{4}` means 4 of them, and `[0-9]` means any number, `{3}` means 3 of them. The brackets around the two parts of the regex mean we want to extract those parts. The first part goes into `cell_type` and the second part goes into `cell_number`. The `_` between the two patterns matches the underscore and the fact it isn't in a bracket means we don't want to keep it.

We can now plot the PC1 and PC2 scores.


üé¨ Plot PC1 against PC2 and colour the points by cell type:
```{r}
pca <- pca_labelled |> 
  ggplot(aes(x = PC1, y = PC2, 
             colour = cell_type)) +
  geom_point(alpha = 0.4) +
  scale_colour_viridis_d(end = 0.8, begin = 0.15,
                         name = "Cell type") +
  theme_classic()
pca
```

Fairly good separation of cell types but plenty of overlap

üé¨ Save the plot to file:
```{r}
ggsave("figures/prog_hspc-pca.png",
       plot = pca,
       height = 3, 
       width = 4,
       units = "in",
       device = "png")
```

## Visualise all the results with a volcano plot

colour the points if FDR \< 0.05 and prog_hspc_results \> 1

```{r}
library(ggrepel)
```

```{r}

prog_hspc_results <- prog_hspc_results |> 
  mutate(log10_FDR = -log10(FDR),
         sig = FDR < 0.05,
         bigfc = abs(summary.logFC) >= 2) 
```

```{r}
vol <- prog_hspc_results |> 
  ggplot(aes(x = summary.logFC, 
             y = log10_FDR, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray",
                                 "pink",
                                 "deeppink")) +
  geom_text_repel(data = subset(prog_hspc_results, 
                                bigfc & sig),
                  aes(label = external_gene_name),
                  size = 3,
                  max.overlaps = 50) +
  theme_classic() +
  theme(legend.position = "none")
vol
```

```{r}
ggsave("figures/prog-hspc-volcano.png",
       plot = vol,
       height = 4.5, 
       width = 4.5,
       units = "in",
       device = "png")
```

<!-- The dataframe `res_prog_hspc$prog` is log prog - log hspc -->

<!-- (i.e.,Prog/HSPC). This means - Positive fold change: prog is higher than -->

<!-- hspc - Negative fold change: hspc is higher than prog -->

<!-- The dataframe `res_prog_hspc$hspc` is log hspc - log prog (i.e., -->

<!-- HSPC/Prog). . This means - Positive fold change: hspc is higher than -->

<!-- prog - Negative fold change: prog is higher than hspc -->
