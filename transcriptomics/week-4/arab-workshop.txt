---
title: "Workshop"
subtitle: "Transcripttranscriptomics 2: Statistical Analysis"
author: "Emma Rand"
toc: true
toc-depth: 4
toc-location: right
execute:
  echo: true
  include: true
  error: true
bibliography: ../../references.bib
editor: 
  markdown: 
    wrap: 72
---

# Introduction

## Session overview

In the workshop, you will learn how to perform differential expression
analysis on raw counts using **`DESeq2`** [@DESeq2] or on logged
normalised expression values using **`scran`** [@scran] or both.

# Set up

## 🐸 Frog development

🎬 Open the `frogs-88H` RStudio Project and the `cont-fgf-s30.R` script.

## 🎄 Arabidopisis

🎬 Open the `arabi-88H` RStudio Project and the `wildsuf-wilddef-s30.R` script.

## 💉 Leishmania mexicana

🎬 Open the `leish-88H` RStudio Project and the `pro-meta-s30.R` script.

## 🐭 Stem cells

🎬 Open the `mice-88H` RStudio Project and the `hspc-prog.R` script.


## Everyone

🎬 Make a new folder `results` in the project directory. 

This is where we will save our results.

🎬 Load **`tidyverse`** [@tidyverse] You most likely have this code at
the top of `your script already.

```{r}
library(tidyverse)
```

```         
── Attaching core tidyverse packages ─────────────────────────────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.3     ✔ readr     2.1.4
✔ forcats   1.0.0     ✔ stringr   1.5.0
✔ ggplot2   3.4.3     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.0
✔ purrr     1.0.2     
── Conflicts ───────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package to force all conflicts to become errors
```

Have you ever stopped to think about this message? It is telling us that
there are functions in the `dplyr` package that have the same name as
functions in the `stats` package and that R will use the `dplyr`
version. As this is what you want, this has always been fine. It still
is fine in this case. However, as you start to load more packages, you
will want to know if you are using a function from a package that has
the same name as a function in another loaded package. This is where the
**`conflicted`** [@conflicted] package comes in. **`Conflicted`** will
warn you when you are using a function that has the same name as a
function in another package. You can then choose which function to use.

🎬 Load the **`conflicted`** package:

```{r}
library(conflicted)
```

Instead of getting a warning every time you are using a function that
has a function with the same name in another package, we can declare a
preference for one function over another. This is useful for the
functions you use a lot or ones where you are certain you always want to
use a particular function.

For example, to always use the **`dplyr`** version of `filter()` by default you can add this to the top of your script:

```{r}
conflict_prefer("filter", "dplyr")
```

# Import 

## 🐸 Frog development

We need to import the S30 data that were filtered to remove genes with
4, 5 or 6 zeros and those where the total counts was less than 20.

🎬 Import the data from the `data-processed` folder.

```{r}
#| echo: false
#---CODING ANSWER---
s30_filtered <- read_csv("data-processed/s30_filtered.csv")
```
Now go to [Differential Expression Analysis](#differential-expression-analysis).

## 🎄 Arabidopisis
Import

Now go to [Differential Expression Analysis](#differential-expression-analysis).


## 💉 Leishmania mexicana
Import

Now go to [Differential Expression Analysis](#differential-expression-analysis).

## 🐭 Stem cells
Import

Now go to [Differential Expression Analysis](#differential-expression-analysis).


# Differential Expression Analysis

## 🐸 Frog development

These are the steps we will take

1.  Find the genes that are expressed in only one treatment group.
2.  Create a DESeqDataSet object. This is a special object that is used
    by the **`DESeq2`** package
3.  Prepare the normalised counts from the DESeqDataSet object.
4.  Do differential expression analysis on the genes. This needs to be
    done on the raw counts.

The all but the first step are done with the **`DESeq2`** package

### 1. Genes expressed in one treatment

The genes expressed in only one treatment group are those with zeros in
all three replicates in one group and non-zero values in all three
replicates in the other group. For example, those shown here:

```{r}
#| echo: false
# sort the data by the values in the control column
s30_filtered |>  
  arrange(S30_C_3) |> 
  head(3) |> 
  knitr::kable()

```

We will use `filter()` to find these genes.

🎬 Find the genes that are expressed only in the FGF-treated group:

```{r}
s30_fgf_only <- s30_filtered |> 
  filter(S30_C_1 == 0, 
         S30_C_2 == 0, 
         S30_C_3 == 0, 
         S30_F_1 > 0, 
         S30_F_2 > 0, 
         S30_F_3 > 0)
```

❓ How many genes are expressed only in the FGF-treated group?

<!-- #---THINKING ANSWER--- -->

<!-- There are 26 genes expressed only in the FGF-treated group. -->

🎬 Now you find any genes that are expressed only in the control group.

```{r}
#| echo: false
#---CODING ANSWER---
s30_con_only <- s30_filtered |> 
  filter(S30_C_1 > 0, 
         S30_C_2 > 0, 
         S30_C_3 > 0, 
         S30_F_1 == 0, 
         S30_F_2 == 0, 
         S30_F_3 == 0)

```

❓ How many genes are expressed only in the control group?

<!-- #---THINKING ANSWER--- -->

<!-- There are 0 genes expressed only in the control group. -->

❓ Do the results make sense to you in light of what you know about the
biology?

<!-- #---THINKING ANSWER--- -->

<!-- Since FGF is a growth factor, it is likely to induce the expression  -->
<!-- of genes. Therefore, it is not surprising to me that there are no  -->
<!-- genes expressed in the control group but not in the FGF-treated  -->
<!-- group. However, I'm not an expert in developmental biology. -->

<!-- Domain expertise is important when analysing data so  -->
<!-- discuss your results with Betsy and your group. -->

🎬 Write all the genes that are expressed one group only to file 
(saved in `results`)

```{r}
#| echo: false
#---CODING ANSWER---
write_csv(s30_fgf_only, "results/s30_fgf_only.csv")
```

### 2. Create DESeqDataSet object

🎬 Load the DESeq2 package:

```{r}
#| echo: false
#---CODING ANSWER---
library(DESeq2)
```

A DEseqDataSet object is a custom data type that is used by
**`DESeq2`**. Custom data types are common in the Bioconductor[^1]
packages. They are used to store data in a way that is useful for the
analysis. These data types typically have data, transformed data,
metadata and experimental designs within them.

[^1]: [Bioconductor](https://www.bioconductor.org/) is a project that
    develops and supports R packages for bioinformatics.

To create a DESeqDataSet object, we need to provide three things:

-  The raw counts - these are in `s30_filtered`
-  The meta data which gives information about the samples and which
    treatment groups they belong to
-  A design matrix which captures the design of the statistical model.

The counts must in a *matrix* rather than a dataframe. Unlike a dataframe,
a matrix has columns of all the same type. That is, it will contain only
the counts. The gene ids are given as row names rather than a column.
The `matrix()` function will create a matrix from a dataframe of columns
of the same type and the `select()` function can be used to remove the
gene ids column.

🎬 Create a matrix of the counts:

```{r}
s30_count_mat <- s30_filtered |>
  select(-xenbase_gene_id) |>
  as.matrix()
```

🎬 Add the gene ids as row names to the matrix:

```{r}
# add the row names to the matrix
rownames(s30_count_mat) <- s30_filtered$xenbase_gene_id

```

You might want to view the matrix (click on it in your environment pane).

The metadata are in a file,
[frog_meta_data.txt](meta/frog_meta_data.txt). This is a
tab-delimited file. The first column is the sample name and the second
column is the treatment group.

🎬 Make a folder called `meta` and save the file to it.

🎬 Read the metadata into a dataframe:

```{r}
meta <- read_table("meta/frog_meta_data.txt")
```

🎬 Examine the resulting dataframe.

We need to add the sample names as row names to the metadata dataframe.
This is because the DESeqDataSet object will use the row names to match
the samples in the metadata to the samples in the counts matrix.

🎬 Add the sample names as row names to the metadata dataframe:

```{r}
row.names(meta) <- meta$sample_id
```

(you will get a warning message but you can ignore it)

We are dealing only with the S30 data so we need to remove the samples
that are not in the S30 data.

🎬 Filter the metadata to keep only the S30 information:

```{r}
meta_s30 <- meta |>
  filter(stage == "stage_30")
```


We can now create the DESeqDataSet object. The design formula describes
the statistical model. You should the form from previous work. The `~` 
indicates that the left hand side is the response variable (in this case
the counts) and the right hand side are the explanatory variables. 
We are interested in the difference between the treatments but we include `sibling_rep` to account for the fact that the data are paired. 

Note that:

-   The names of the columns in the count matrix have to exactly match 
    the names of the rows in the metadata dataframe. They also need 
    to be in the same order.
-   The names of the explanatory variables in the design formula have 
    to match the names of columns in the metadata.

🎬 Create the DESeqDataSet object:

```{r}
dds <- DESeqDataSetFromMatrix(countData = s30_count_mat,
                              colData = meta_s30,
                              design = ~ treatment + sibling_rep)
```

The warning "Warning: some variables in design formula are characters,
converting to factors" just means that the variable type of treatment
and sibling_rep in the metadata dataframe are "char" and they have been
converted into the factors.

To help you understand what the `DESeqDataSet` object we have called 
`dds` contains, we can look its contents

The counts are in `dds@assays@data@listData[["counts"]]` and the
metadata are in `dds@colData` but the easiest way to see them is to use
the `counts()` and `colData()` functions from the **`DESeq2`** package.

🎬 View the counts:

```{r}
counts(dds) |> View()
```

You should be able to see that this is the same as in `s30_count_mat`.

```{r}
colData(dds)

```

### 3. Prepare the normalised counts

The normalised counts are the counts that have been transformed to
account for the library size (i.e., the total number of reads in a
sample) and the gene length. We have to first estimate the normalisation
factors and store them in the DESeqDataSet object and then we can get
the normalised counts.

🎬 Estimate the factors for normalisation and store them in the
DESeqDataSet object:

```{r}
dds <- estimateSizeFactors(dds)
```

🎬 Look at the factors (just for information):

```{r}
sizeFactors(dds)
```

The normalised counts will be useful to use later. To get the normalised 
counts we again used the `counts()` function but this time we use the `normalized=TRUE` argument.

🎬 Save the normalised to a matrix:

```{r}
normalised_counts <- counts(dds, normalized = TRUE)
```

We will write the normalised counts to a file so that we can use them in
the future.

🎬 Make a dataframe of the normalised counts, adding a column for the gene
ids at the same time:

```{r}
s30_normalised_counts <- data.frame(normalised_counts,
                                    xenbase_gene_id = row.names(normalised_counts))

```

### 4. Differential expression analysis

We use the `DESeq()` function to do the differential expression
analysis. This function fits the statistical model to the data and then
uses the model to calculate the significance of the difference between
the treatments. It again stores the results in the DESseqDataSet object.
Note that the differential expression needs the raw (unnormalised
counts) as it does its own normalisation as part of the process.

🎬 Run the differential expression analysis and store the results in 
   the same object:

```{r}
dds <- DESeq(dds)
```

The function will take only a few moments to run on this data but can
take longer for bigger datasets.

We need to define the contrasts we want to test. We want to test the
difference between the treatments so we will define the contrast as
`FGF` and `control`.

🎬 Define the contrast:

```{r}
contrast_fgf <- c("treatment", "FGF", "control")
```

Note that `treatment` is the name of the column in the metadata
dataframe and `FGF` and `control` are the names of the levels in the
`treatment` column. By putting them in the order `FGF` , `control` we
are saying the fold change will be FGF / control.  This means:

-   positive log fold changes indicate FGF \> control and
-   negative log fold changes indicates control \> FGF.

If we had put them in the order `control`, `FGF` we would have the reverse.

🎬 Extract the results from the DESseqDataSet object:

```{r}
results_fgf <- results(dds,
                       contrast = contrast_fgf)
```

This will give us the log~2~ fold change, the  *p*-value and the 
adjusted  *p*-value between the control and the FGF-treatment for each gene.

🎬 Put the results in a dataframe and add the gene ids as a column:

```{r}
s30_results <- data.frame(results_fgf,
                          xenbase_gene_id = row.names(results_fgf))
```

It is useful to have the normalised counts and the statistical results in one dataframe. 

🎬 Merge the two dataframes:
```{r}
# merge the results with the normalised counts
s30_results <- s30_normalised_counts |>
  left_join(s30_results, by = "xenbase_gene_id")
```


Now go to [Add gene information](#add-gene-information).



## 🎄 Arabidopisis
DE instructions

Now go to [Add gene information](#add-gene-information).

## 💉 Leishmania mexicana
DE instructions

Now go to [Add gene information](#add-gene-information).

## 🐭 Stem cells
DE instructions

Now go to [Add gene information](#add-gene-information).


# Add gene information

## 🐸 Frog development

-   I got the information from the [Xenbase information
    pages](https://www.xenbase.org/xenbase/static-xenbase/ftpDatafiles.jsp)
    under Data Reports \| Gene Information

-   This is listed: Xenbase Gene Product Information \[readme\] [gzipped
    gpi (tab
    separated)](https://download.xenbase.org/xenbase/GenePageReports/xenbase.gpi.gz)

-   Click on the readme link to see the file format and columns

-   I downloaded
    [xenbase.gpi.gz](https://download.xenbase.org/xenbase/GenePageReports/xenbase.gpi.gz),
    unzipped it, removed header lines and the *Xenopus tropicalis*
    (taxon:8364) entries and saved it as
    [xenbase_info.xlsx](meta/xenbase_info.xlsx)

If you want to emulate what I did you can use the following commands in
the terminal after downloading the file:

``` bash
gunzip xenbase.gpi.gz
less xenbase.gpi
q
```

`gunzip` unzips the file and `less` allows you to view the file. `q`
quits the viewer. You will see the header lines and that the file
contains both *Xenopus tropicalis* and *Xenopus laevis*. I read the file
in with `read_tsv` (skipping the first header lines) then filtered out
the *Xenopus tropicalis* entries, dropped some columns and saved the
file as an excel file.

However, I have already done this for you and saved the file as [xenbase_info.xlsx](meta/xenbase_info.xlsx) in the `meta` folder. We will import this file and join it to the results dataframe.

🎬 Load the **`readxl`** [@readxl] package:

```{r}
library(readxl)
```

🎬 Import the Xenbase gene information file:

```{r}
gene_info <- read_excel("meta/xenbase_info.xlsx") 
```

You should view the resulting dataframe to see what information is
available. You can use `glimpse()` or `View()`.

🎬 Merge the gene information with the results:

```{r}
# join the gene info with the results
s30_results <- s30_results |>
  left_join(gene_info, by = "xenbase_gene_id")
```

🎬 Save the results to a file:

```{r}
write_csv(s30_results, file = "results/s30_results.csv")
```


## 🎄 Arabidopisis



## 💉 Leishmania mexicana


## 🐭 Stem cells







# 🤗 Look after future you!

🎬 Go through you script and tidy
up. You might need to :

-   collect together library statements at the top of the script
-   remove code that you needed to start today but which wouldn't be
    needed if you were running the script from the top (e.g., importing)
-   edit your comments for clarity
-   rename variables for consistency or clarity
-   remove house keeping or exploratory code
-   restyle code, add code section headers etc

# 🥳 Finished

Well Done!

# Independent study following the workshop

[Consolidate](study_after_workshop.qmd)

# The Code file

These contain all the code needed in the workshop even where it is not
visible on the webpage.

The [workshop.qmd](workshop.qmd) file is the file I use to compile the
practical. Qmd stands for Quarto markdown. It allows code and ordinary
text to be interleaved to produce well-formatted reports including
webpages. Right-click on the link and choose Save-As to download. You
will be able to open the Qmd file in RStudio. Alternatively, [View in
Browser](https://github.com/3mmaRand/BIO00088H-data/blob/main/transcriptomics/week-4/workshop.qmd). Coding and thinking answers are
marked with `#---CODING ANSWER---` and `#---THINKING ANSWER---`

Pages made with R [@R-core], Quarto [@Allaire_Quarto_2024], `knitr` [@knitr1; @knitr2; @knitr3], `kableExtra` [@kableExtra]

# References
