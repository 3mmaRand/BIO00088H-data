---
title: "Workshop"
subtitle: "Transcriptomics 3: Visualising"
author: "Emma Rand"
toc: true
toc-depth: 4
toc-location: right
execute:
  echo: true
  include: true
  error: true
bibliography: ../../references.bib
editor: 
  markdown: 
    wrap: 72
---

# Introduction

## Session overview

In the workshop, you will learn how to conduct and plot a Principle 
Component Analysis (PCA) as well as how to create a nicely formatted 
Volcano plot. You will also save significant genes to file to make it 
easier to identify genes of interest and perform Gene Ontology (GO) term 
enrichment analysis.

import
log where needed
write sig to file
add go terms
prep data for pca
do pca and plot
volcano
go term enrichment



# Set up

## 🐸 Frog development

🎬 Open the `frogs-88H` RStudio Project and the `cont-fgf-s30.R` script.

## 🎄 *Arabidopsis*

🎬 Open the `arabi-88H` RStudio Project and the `wildsuf-wilddef-s30.R` script.

## 💉 *Leishmania*

🎬 Open the `leish-88H` RStudio Project and the `pro-meta-s30.R` script.

## 🐭 Stem cells

🎬 Open the `mice-88H` RStudio Project and the `hspc-prog.R` script.


## Everyone

🎬 Make a new folder `figures` in the project directory. 

This is where we will save our figure files


🎬 Load **`tidyverse`** [@tidyverse] and **`conflicted`** [@conflicted].
You most likely have this code at the top of your script already.

```{r}
library(tidyverse)
library(conflicted)
```

```         
── Attaching core tidyverse packages ─────────────────────────────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.3     ✔ readr     2.1.4
✔ forcats   1.0.0     ✔ stringr   1.5.0
✔ ggplot2   3.4.3     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.0
✔ purrr     1.0.2     
── Conflicts ───────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package to force all conflicts to become errors
```

I recommend you set the **`dplyr`** versions of `filter()` and `select()` to use by default

🎬 Use the **`dplyr`** version of `filter()` by default:

```{r}
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
```


# Import

## Everyone

🎬 Import your results data. This should be a file in the `results` folder 
called `xxxx_results.csv` where xxxx indicates the comparison you made.

```{r}
#| echo: false
#---CODING ANSWER---
# 🐸 frog development 
# import results data
s30_results <- read_csv("results/S30_results.csv")

```


```{r}
#| echo: false
#---CODING ANSWER---
# 🎄  Arabidopisis
# import results data
wild_results <- read_csv("results/wild_results.csv")

```

```{r}
#| echo: false
#---CODING ANSWER---
# 💉 leihsmania
# import results data
pro_meta_results <- read_csv("results/pro_meta_results.csv")

```


```{r}
#| echo: false
#---CODING ANSWER---
# 🐭 stem cells
# import results data
 # <- read_csv("results/")

```

🎬 Remind yourself what is in the rows and columns and the structure of
the dataframes (perhaps using `glimpse()`)

```{r}
#| include: false
#---CODING ANSWER---
# 🐸 frog development
glimpse(s30_results)
```

<!-- #---THINKING ANSWER--- -->

<!-- You have data with 17 columns and 10136 rows. The rows are the genes. -->
<!-- The columns are the normalised counts for for each of the 6  -->
<!-- samples, the mean of the normalised counts, the xenbase gene id, -->
<!-- the gene name and some data base references.  -->
<!-- You also have the results of a statistical comparison between -->
<!-- the treatments for stage 30: the log fold change, the  -->
<!-- test statistic, the p-value and the adjusted p-value -->


```{r}
#| include: false
#---CODING ANSWER---
# 🎄  Arabidopisis
glimpse(wild_results)
```

<!-- #---THINKING ANSWER--- -->

<!-- You have data with 13 columns and 26355 rows. The rows are the genes. -->
<!-- The columns are the normalised counts for for each of the 4 -->
<!-- samples, the mean of the normalised counts, the gene id, -->
<!-- the gene name and a description. -->
<!-- You also have the results of a statistical comparison between -->
<!-- the Cu sufficient and Cu deficient conditions, the log fold change,  -->
<!-- the test statistic, the p-value and the adjusted p-value -->


```{r}
#| include: false
#---CODING ANSWER---
# 💉 Leishmania
glimpse(pro_meta_results)
```

<!-- #---THINKING ANSWER--- -->

<!-- You have data with 14 columns and 8437 rows. The rows are the genes. -->
<!-- The columns are the normalised counts for for each of the 6 -->
<!-- samples, the mean of the normalised counts, the gene id, -->
<!-- and a description. -->
<!-- You also have the results of a statistical comparison between -->
<!-- the procyclic and metacyclic promastigote stages, the log  -->
<!-- fold change, the test statistic, the p-value and the  -->
<!-- adjusted p-value -->

```{r}
#| include: false
#---CODING ANSWER---
# 🐭 stem cells

```


<!-- #---THINKING ANSWER--- -->



When we do PCA we will want to label the samples with their treatment for 
figures. This labelling information is most easily added using the metadata. 
You will need to select only the samples for the comparison that was made 
in the results file.
You may need to refer back to the [Week 4 Statistical Analysis workshop](../week-4/workshop.html) to remind yourself how to import and 
select the metadata you need

🎬 Import the metadata that maps the sample names to treatments. Remember to select only the samples for comparison that was made. 


```{r}
#| echo: false
#---CODING ANSWER---
# 🐸 frog development 

# Import metadata that maps the sample names to treatments
meta <- read_table("meta/frog_meta_data.txt")

# We only need the s30
meta_s30 <- meta |>
  filter(stage == "stage_30")

```


```{r}
#| echo: false
#---CODING ANSWER---
# 🎄  Arabidopisis
# Import metadata that maps the sample names to treatments
meta <- read_table("meta/arab_meta_data.txt")

# We only need the wild
meta_wild <- meta |>
  filter(genotype == "wt")
```

```{r}
#| echo: false
#---CODING ANSWER---
# 💉 Leishmania
# Import metadata that maps the sample names to treatments
meta <- read_table("meta/leish_meta_data.txt")

# We only need the procyclic and metacyclic promastigote stages
meta_pro_meta <- meta |>
  filter(stage != "amastigotes")
```


```{r}
#| echo: false
#---CODING ANSWER---
# 🐭 stem cells
# Import metadata that maps the sample names to treatments

# meta <- read_table("meta/frog_meta_data.txt")

# # We only need the s30
# meta_s30 <- meta |>
#   filter(stage == "stage_30")
```



# log~2~ transform the normalised counts

We use the normalised counts for data visualisations so that the
comparisons are meaningful. Since the fold changes are given is log~2~
it is useful to log~2~ transform the normalised counts too. We will add
columns to the dataframe with these transformed values. Since we have
some counts of 0 we will add a tiny amount to avoid `-Inf` values.

log~2~ transformation would be applied to one column like this:

```{r}
#| eval: false
# DO NOT DO
# log2 transform the counts plus a tiny amount to avoid log(0)
dataframe <- dataframe |>
  mutate(log2_mycolumn = log2(mycolumn + 0.001))
```


We are going to use a wonderful bit of R wizardry to apply a transformation to multiple columns. This is the `across()` function which has three arguments:

```
across(.cols, .fns, .names)
```

where:

- `.cols` is the selection of columns to transform
- `.fns` is the function we want to apply to the selected columns
- `.names` is the naming convention for the new columns

The general form of the code you need is:

```{r}
#| eval: false
# DO NOT DO
# log2 transform the counts plus a tiny amount to avoid log(0)
xxxx_results <- xxxx_results |>
  mutate(across(starts_with("pattern"), 
                \(x) log2(x + 0.001),
                .names = "log2_{.col}"))
```

where:

-   `xxxx_results` is the name of the dataframe of results
-   `pattern` matches the starting letters for all of the normalised 
     counts so that `starts_with("pattern")` gives the selection 
     of columns to transform
-    the bit after the `\(x)` is the function we want to apply to
     the selected columns
-    the `\(x)` means it is an "anonymous" function which means we don't
     have to define a function name. 
-    `"log2_{.col}"`  means the columns will have the same name 
     (in the `.col`) but with the prefix `log2_` added.

You can read more about `across()` and anonymous functions from my 
[posit::conf(2024) workshop](https://posit-conf-2024.github.io/programming-r/)


## 🐸 Frog development, 🎄 *Arabidopsis* and 💉 *Leishmania*

🎬 Design the code to log~2~ transform the normalised counts using the 
   template given

```{r}
#| include: false
#---CODING ANSWER---
# 🐸 frog development
# log2 transform the counts plus a tiny amount to avoid log(0)
s30_results <- s30_results |>
  mutate(across(starts_with("s30"), 
                \(x) log2(x + 0.001),
                .names = "log2_{.col}"))
```


```{r}
#| include: false
#---CODING ANSWER---
# 🎄 Arabidopsis
# log2 transform the counts plus a tiny amount to avoid log(0)
wild_results <- wild_results |>
  mutate(across(starts_with("SRX"),
                \(x) log2(x + 0.001),
                .names = "log2_{.col}"))
```


```{r}
#| include: false
#---CODING ANSWER---
# 💉 Leishmania
# log2 transform the counts plus a tiny amount to avoid log(0)
pro_meta_results <- pro_meta_results |>
  mutate(across(starts_with("lm_"), 
                \(x) log2(x + 0.001),
                .names = "log2_{.col}"))
```


I recommend viewing the dataframe to see the new columns. Check you have the 
expected number of columns.

## 🐭 Stem cells 

You do not need to apply this transformation because the data is already log~2~ 
transformed.


## Everyone

We now all have dataframes with all the information we need: normalised
counts, log~2~ normalised counts, statistical comparisons with fold
changes and *p*-values, and information about the gene.

# Write the significant genes to file

## Everyone

We will create dataframe of the significant genes and write them to file.
This is subset from the results file but will make it a little easier to 
examine and select genes of interest.

The general form of the code you need is:

```{r}
#| eval: false
# DO NOT DO
# create a dataframe of genes significant at 0.05 level
xxxx_results_sig0.05 <- xxxx_results |> 
  filter(padj <= 0.05)

```

Note that you determine the significance level using the adjusted *p*-values
(named `padj` or `FDR`) rather than the uncorrected *p*-values.


🎬 Create a dataframe of the genes significant at the 0.05 level.

```{r}
#| include: false
#---CODING ANSWER---
# 🐸 frog development
# create a dataframe of genes significant at 0.05 level
s30_results_sig0.05 <- s30_results |> 
  filter(padj <= 0.05)

```

```{r}
#| include: false
#---CODING ANSWER---
# 🎄 Arabidopsis
# create a dataframe of genes significant at 0.05 level
wild_results_sig0.05 <- wild_results |> 
  filter(padj <= 0.05)

```

```{r}
#| include: false
#---CODING ANSWER---
# 💉 Leishmania
# create a dataframe of genes significant at 0.05 level
pro_meta_results_sig0.05 <- pro_meta_results |> 
   filter(padj <= 0.05)

```

```{r}
#| include: false
#---CODING ANSWER---
# 🐭 Stem cells
# create a dataframe of genes significant at 0.05 level
# s30_results_sig0.05 <- s30_results |> 
#   filter(padj <= 0.05)

```

❓How many genes are significant at the 0.05 levels?

<!-- #---THINKING ANSWER--- -->

<!-- 🐸 frog development  -->
<!-- 117 genes are significant at the 0.05 level. -->

<!-- 🎄 Arabidopsis  -->
<!-- 12 genes are significant at the 0.05 level. -->


<!-- 💉 leishmania  -->
<!-- 3252 genes are significant at the 0.05 level. -->
<!-- I recommend using a more stringent cut-off such as 0.01  -->

<!-- 🐭 stemcells -->
<!-- ## genes are significant at the 0.05 level. -->

If you have a very large number of genes significant at the 0.05 level, 
you may want to consider a more stringent cut-off such as 0.01.

```{r}
#| include: false
#---CODING ANSWER---
# 💉 Leishmania
# create a dataframe of genes significant at 0.01 level
pro_meta_results_sig0.01 <- pro_meta_results |> 
   filter(padj <= 0.01)

# there are still 2370 genes significant at the 0.01 level


```



🎬 Write the dataframe to a csv file. I recommend using the same file name
   as you used for the dataframe.


```{r}
#| include: false
#---CODING ANSWER---
# 🐸 frog development
# write to csv file
write_csv(s30_results_sig0.05, 
          file = "results/s30_results_sig0.05.csv")
```


```{r}
#| include: false
#---CODING ANSWER---
# 🎄 Arabidopsis
# write to csv file
write_csv(wild_results_sig0.05, 
          file = "results/wild_results_sig0.05.csv")
```

```{r}
#| include: false
#---CODING ANSWER---
# 💉 Leishmania
# write to csv file
write_csv(pro_meta_results_sig0.05, 
          file = "results/wild_results_sig0.05.csv")

write_csv(pro_meta_results_sig0.01, 
          file = "results/wild_results_sig0.01.csv")

```

```{r}
#| include: false
#---CODING ANSWER---
# 🐭 Stem cells
# write to csv file

```

Now go to PCA for:

-   [🐸 Frog development](#frog-development-1)
-   [🎄 Arabidopsis](#arabidopsis-1)
-   [💉 Leishmania](#leishmania-1)
-   [🐭 Stem cells](#stem-cells-2)


# Principal Component Analysis (PCA)

We have many genes in our datasets. PCA will allow us to plot our
samples in the "gene expression" space so we can see if replicates with the
same treatment cluster together as we would expect. PCA is a dimension
reduction technique that finds the directions of maximum variance in the
data. We are doing PCA after our statistical analysis but often it is one 
of the first techniques used to explore the data. If we do not see treatment
effects in a PCA plot then we are not likely to see them in the statistical
analysis. PCA can also help you identify any outlier replicates. The PCA 
is best conducted on the normalised counts or the log~2~ transformed 
normalised counts. We will use the log~2~ transformed normalised counts.

We will carry out the following steps to do the PCA:

-   Select the log~2~ transformed normalised counts. You can only use 
    numerical data in PCA. 
-   Transpose our data. We have genes in rows and samples in 
    columns (this is common for gene expression data). However, 
    to treatment the genes as variables, PCA expects samples in rows and 
    genes in columns. 
-   Add the gene names as column names in the transposed data
-   Perform the PCA
-   Extract the scores on the first two principal components and label
    the data
-   Plot the the first two principal components as a scatter plot

In each case we will use only the samples for the comparison that was made
in the PCA. However, it would be informative to do PCA on all the 
samples you have and that is something you may want to consider in your
independent study.

## 🐸 Frog development



🎬 Transpose the log~2~ transformed normalised counts:

```{r}
s30_log2_trans <- s30_results |> 
  select(starts_with("log2_")) |>
  t() |> 
  data.frame()
```

We have used the `select()` function to select all the columns that
start with `log2_`. We then use the `t()` function to transpose the
dataframe. We then convert the resulting matrix to a dataframe using
`data.frame()`. If you view that dataframe you'll see it has default
column name which we can fix using `colnames()` to set the column names
to the Xenbase gene ids.

🎬 Set the column names to the Xenbase gene ids:

```{r}
colnames(s30_log2_trans) <- s30_results$xenbase_gene_id
```

🎬 Perform PCA on the log~2~ transformed normalised counts:

```{r}
pca <- s30_log2_trans |>
  prcomp(rank. = 4) 
```

The `rank.` argument tells `prcomp()` to only calculate the first 4
principal components. This is useful for visualisation as we can only
plot in 2 or 3 dimensions. We can see the results of the PCA by viewing
the `summary()` of the `pca` object.

```{r}
summary(pca)
```

The Proportion of Variance tells us how much of the variance is
explained by each component. We can see that the first component
explains 0.4243 of the variance, the second 0.2320, and the third
0.1532. Together the first three components explain nearly 81% of the
total variance in the data. Plotting PC1 against PC2 will capture about
66% of the variance which is likely very much better than we would get
plotting any two genes against each other. To plot the PC1 against PC2
we will need to extract the PC1 and PC2 "scores" from the PCA object and
add labels for the samples. Those labels will come from the row names of 
the transformed data which has the sample ids and from the metadata.

🎬 Create a vector of the sample ids from the row names. These include 
the `log2` prefix which we can removed for labelling:

```{r}
sample_id <- row.names(s30_log2_trans) |> str_remove("log2_")
```

You might want to check the result.

Now we will extract the PC1 and PC2 scores from the PCA object and add. 
Our PCA object is called `pca` and the scores are in pca$x. We will 
create a dataframe of the scores and add the sample ids.

🎬 Create a dataframe of PC1 and PC2 scores and add the sample ids:

```{r}
pca_labelled <- data.frame(pca$x,
                           sample_id)
```

🎬 Merge with the metadata so we can label points by treatment and
sibling pair:

```{r}
pca_labelled <- pca_labelled |> 
  left_join(meta_s30, 
            by = "sample_id")
```

Since the metadata contained the sample ids, it was especially important
to remove the `log2_` from the row names so that the join would work.

The dataframe should look like this:

```{r}
#| echo: false
knitr::kable(pca_labelled)
```

The next task is to plot PC2 against PC1 and colour by sibling pair. This 
is just a scatterplot so we can use `geom_point()`. We will use colour
to indicate the sibling pair and shape to indicate the treatment. 

🎬 Customise the PC2 against PC1 plot:

```{r}
pca_labelled |> 
  ggplot(aes(x = PC1, y = PC2, 
             colour = sibling_rep,
             shape = treatment)) +
  geom_point(size = 3) +
  theme_classic()

```

There is a good separation between treatments on PCA1. The sibling pairs
do not seem to cluster together. You can also try plotting PC3 or PC4.

I prefer to customise the colours and shapes. I especially like the  
viridis colour scales which provide colour scales that are perceptually 
uniform in both colour and black-and-white. They are also designed to 
be perceived by viewers with common forms of colour blindness. See 
[Introduction to viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html#introduction) for more information.

`ggplot` provides functions to access the viridis scales. Here I use
`scale_fill_viridis_d()`. The d stands for discrete. The 
function `scale_fill_viridis_c()` would be used for continuous data. 
I’ve used the default “viridis” (or “D”) option (do ?scale_fill_viridis_d for all the options) and used the `begin` and `end` arguments to control the range of 
colour - I have set the range to be from 0.15 to 0.95 the avoid the 
strongest contrast. I have also set the `name` argument to provide a
label for the legend.

I have used `scale_shape_manual()` to set the shapes for the treatments.
I have used the values 21 and 19 which are the codes for filled and open
circles and filled triangles. I have set the `name` argument to `NULL` 
to remove the label (it's obvious what that categories are treatments) 
and the `labels` argument to improve the legend.


🎬 Plot PC2 against PC1 and colour by sibling pair and shape by
treatment:

```{r}
pca_labelled |> 
  ggplot(aes(x = PC1, y = PC2, 
             colour = sibling_rep,
             shape = treatment)) +
  geom_point(size = 3) +
  scale_colour_viridis_d(end = 0.95, begin = 0.15,
                         name = "Sibling pair") +
  scale_shape_manual(values = c(21, 19),
                     name = NULL,
                     labels = c("Control", "FGF-Treated")) +
  theme_classic()

```

Now go to Volcano plots for [🐸 Frog development](#frog-development-2)


## 🎄 *Arabidopsis* 


🎬 Transpose the log~2~ transformed normalised counts:

```{r}
wild_log2_trans <- wild_results |> 
  select(starts_with("log2_")) |>
  t() |> 
  data.frame()
```

We have used the `select()` function to select all the columns that
start with `log2_`. We then use the `t()` function to transpose the
dataframe. We then convert the resulting matrix to a dataframe using
`data.frame()`. If you view that dataframe you'll see it has default
column name which we can fix using `colnames()` to set the column names
to the Xenbase gene ids.

🎬 Set the column names to the gene ids:

```{r}
colnames(wild_log2_trans) <- wild_results$gene_id
```

🎬 Perform PCA on the log~2~ transformed normalised counts:

```{r}
pca <- wild_log2_trans |>
  prcomp(rank. = 4, scale = TRUE)
```

The `scale` argument tells `prcomp()` to scale the data before doing the
PCA. This is important when the variables are on different scales to stop variables with large values dominating the PCA.
The `rank.` argument tells `prcomp()` to only calculate the first 4
principal components. This is useful for visualisation as we can only
plot in 2 or 3 dimensions. We can see the results of the PCA by viewing
the `summary()` of the `pca` object.

```{r}
summary(pca)
```

The Proportion of Variance tells us how much of the variance is
explained by each component. We can see that the first component
explains 0.5742 of the variance, the second 0.2786, and the third
0.1472. Together the first three components explain nearly 100% of the
total variance in the data. Plotting PC1 against PC2 will capture about
92% of the variance which is very likely very much better than we would get
plotting any two genes against each other. To plot the PC1 against PC2
we will need to extract the PC1 and PC2 "scores" from the PCA object and
add labels for the samples. Those labels will come from the row names of 
the transformed data which has the sample ids and from the metadata.

🎬 Create a vector of the sample ids from the row names. These include 
the `log2` prefix which we can removed for labelling:

```{r}
sample_id <- row.names(wild_log2_trans) |> str_remove("log2_")
```

You might want to check the result.

Now we will extract the PC1 and PC2 scores from the PCA object and add. 
Our PCA object is called `pca` and the scores are in pca$x. We will 
create a dataframe of the scores and add the sample ids.

🎬 Create a dataframe of PC1 and PC2 scores and add the sample ids:

```{r}
pca_labelled <- data.frame(pca$x,
                           sample_id)
```

🎬 Merge with the metadata so we can label points by treatment and
sibling pair:

```{r}
pca_labelled <- pca_labelled |> 
  left_join(meta_wild, 
            by = "sample_id")
```

Since the metadata contained the sample ids, it was especially important
to remove the `log2_` from the row names so that the join would work.

The dataframe should look like this:

```{r}
#| echo: false
knitr::kable(pca_labelled)
```

The next task is to plot PC2 against PC1 and colour by copper conditions. This 
is just a scatterplot so we can use `geom_point()`. We will use colour
to indicate the copper conditions. 

🎬 Plot PC2 against PC1 and colour by copper conditions:

```{r}
pca_labelled |> 
  ggplot(aes(x = PC3, y = PC2, 
             colour = copper)) +
  geom_point(size = 3) +
  theme_classic()

```

We do not see particularly good separation between treatments, though
perhaps there is some separation between the copper sufficient and
copper deficient on PC2. It is also difficult to see if the replicates
cluster together (the treatments separate) when there are only two reps.
You can also try plotting PC3 or PC4.

I prefer to customise the colours and shapes. I especially like the  
viridis colour scales which provide colour scales that are perceptually 
uniform in both colour and black-and-white. They are also designed to 
be perceived by viewers with common forms of colour blindness. See 
[Introduction to viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html#introduction) for more information.

`ggplot` provides functions to access the viridis scales. Here I use
`scale_fill_viridis_d()`. The d stands for discrete. The 
function `scale_fill_viridis_c()` would be used for continuous data. 
I’ve used the default “viridis” (or “D”) option (do ?scale_fill_viridis_d for all the options) and used the `begin` and `end` arguments to control the range of 
colour - I have set the range to be from 0.15 to 0.95 the avoid the 
strongest contrast. I have also set the `name` argument to provide a
label for the legend.


🎬 Customise the PC2 against PC1 plot:

```{r}
pca_labelled |> 
  ggplot(aes(x = PC1, y = PC2, 
             colour = copper)) +
  geom_point(size = 3) +
  scale_colour_viridis_d(end = 0.95, begin = 0.15,
                         name = "Copper") +
  theme_classic()

```

Now go to Volcano plots for [🎄 Arabidopsis](#arabidopsis-2)
-   [💉 Leishmania](#leishmania-1)
-   [🐭 Stem cells](#stem-cells-2)


## 💉 *Leishmania* 



🎬 Transpose the log~2~ transformed normalised counts:

```{r}
pro_meta_log2_trans <- pro_meta_results |> 
  select(starts_with("log2_")) |>
  t() |> 
  data.frame()
```

We have used the `select()` function to select all the columns that
start with `log2_`. We then use the `t()` function to transpose the
dataframe. We then convert the resulting matrix to a dataframe using
`data.frame()`. If you view that dataframe you'll see it has default
column name which we can fix using `colnames()` to set the column names
to the Xenbase gene ids.

🎬 Set the column names to the gene ids:

```{r}
colnames(pro_meta_log2_trans) <- pro_meta_results$gene_id
```

🎬 Perform PCA on the log~2~ transformed normalised counts:

```{r}
pca <- pro_meta_log2_trans |>
  prcomp(rank. = 4, scale = TRUE) 
```

The `scale` argument tells `prcomp()` to scale the data before doing the
PCA. This is important when the variables are on different scales to stop variables with large values dominating the PCA.
The `rank.` argument tells `prcomp()` to only calculate the first 4
principal components. This is useful for visualisation as we can only
plot in 2 or 3 dimensions. We can see the results of the PCA by viewing
the `summary()` of the `pca` object.

```{r}
summary(pca)
```

The Proportion of Variance tells us how much of the variance is
explained by each component. We can see that the first component
explains 0.5175 of the variance, the second 0.2088, and the third
0.1025. Together the first three components explain nearly 92% of the
total variance in the data. Plotting PC1 against PC2 will capture about
66% of the variance which is likely very much better than we would get
plotting any two genes against each other. To plot the PC1 against PC2
we will need to extract the PC1 and PC2 "scores" from the PCA object and
add labels for the samples. Those labels will come from the row names of 
the transformed data which has the sample ids and from the metadata.

🎬 Create a vector of the sample ids from the row names. These include 
the `log2` prefix which we can removed for labelling:

```{r}
sample_id <- row.names(pro_meta_log2_trans) |> str_remove("log2_")
```

You might want to check the result.

Now we will extract the PC1 and PC2 scores from the PCA object and add. 
Our PCA object is called `pca` and the scores are in pca$x. We will 
create a dataframe of the scores and add the sample ids.

🎬 Create a dataframe of PC1 and PC2 scores and add the sample ids:

```{r}
pca_labelled <- data.frame(pca$x,
                           sample_id)
```

🎬 Merge with the metadata so we can label points by life cycle stage:

```{r}
pca_labelled <- pca_labelled |> 
  left_join(meta_pro_meta, 
            by = "sample_id")
```

Since the metadata contained the sample ids, it was especially important
to remove the `log2_` from the row names so that the join would work.

The dataframe should look like this:

```{r}
#| echo: false
knitr::kable(pca_labelled)
```

The next task is to plot PC2 against PC1 and colour by sibling pair. This 
is just a scatterplot so we can use `geom_point()`. We will use colour
to indicate the life cycle stage. 

🎬 Plot PC2 against PC1 and colour by copper conditions:

```{r}
pca_labelled |> 
  ggplot(aes(x = PC1, y = PC2, 
             colour = stage)) +
  geom_point(size = 3) +
  theme_classic()

```

There is a good separation between treatments on PCA1. The replicates
do seem to cluster together. You can also try plotting PC3 or PC4.

I prefer to customise the colours. I especially like the  
viridis colour scales which provide colour scales that are perceptually 
uniform in both colour and black-and-white. They are also designed to 
be perceived by viewers with common forms of colour blindness. See 
[Introduction to viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html#introduction) for more information.

`ggplot` provides functions to access the viridis scales. Here I use
`scale_fill_viridis_d()`. The d stands for discrete. The 
function `scale_fill_viridis_c()` would be used for continuous data. 
I’ve used the default “viridis” (or “D”) option (do ?scale_fill_viridis_d for all the options) and used the `begin` and `end` arguments to control the range of 
colour - I have set the range to be from 0.15 to 0.95 the avoid the 
strongest contrast. I have also set the `name` argument to provide a
label for the legend.


🎬 Plot PC2 against PC1 and colour by life stage:

```{r}
pca_labelled |> 
  ggplot(aes(x = PC1, y = PC2, 
             colour = stage)) +
  geom_point(size = 3) +
  scale_colour_viridis_d(end = 0.95, begin = 0.15,
                         name = "Stage") +
  theme_classic()

```


Now go to Volcano plots for [💉 Leishmania](#leishmania-2)


## 🐭 Stem cells 




Now go to Volcano plots for [🐭 Stem cells](#stem-cells-3)

# Visualise all the results with a volcano plot

A volcano plot is a scatterplot that shows statistical significance
(p-value) versus magnitude of change (fold change). As the 
[independent study](study_before_workshop.html) explained, we plot
-log~10~(adjusted *p*-value) on the *y*-axis so that the most significant 
genes are uppermost.



## 🐸 Frog development

We will add a column to the results dataframe that contains the 
-log~10~(padj). You could perform this transformation within the 
plot command without adding a column to the data if you prefer.

🎬  Add a column to the results dataframe that contains the -log~10~(padj):
```{r}
s30_results <- s30_results |> 
  mutate(log10_padj = -log10(padj)) 
```

🎬  Create a volcano plot of the results:
```{r}
s30_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(legend.position = "none")

```

Our dashed lines are at -log~10~(0.05) and log~2~(2) and log~2~(-2) to make
more clear which genes (points) are significantly different between the 
control and the FGF-treated samples and have a fold change of at least 2.

In most cases, people colour the points to show that the quadrants. I 
like to add columns to the dataframe to indicate if the gene is significant
and if the fold change is large and use those variables in the plot.

🎬  Add columns to the results dataframe to indicate if the gene is 
significant and if the fold change is large:
```{r}
s30_results <- s30_results |> 
  mutate(sig = padj <= 0.05,
         bigfc = abs(log2FoldChange) >= 2) 
```

The use of `abs()` (absolute) means genes with a fold change of at least 2 
in either direction will be considered to have a large fold change.

Now we can colour the points by these new columns. I use `interaction()` 
to create four categories: 

-   not significant and not large fold change (FF)
-   significant and not large fold change (TF)
-   not significant and large fold (FT)
-   significant and large fold change (TT)

And I use `scale_colour_manual()` to set the colours for these categories.

🎬  Create a volcano plot of the results with the points coloured by
significance and fold change:

```{r}
s30_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                                 "pink",
                                 "gray30",
                                 "deeppink")) +
  theme_classic() +
  theme(legend.position = "none")

```

For exploring the data, I like add labels to all the significant 
genes with a large fold change so I can very quickly identity them. The
`ggrepel` package has a function `geom_text_repel()` that is useful for 
adding labels so that they don't overlap.

🎬  Load the package:
```{r}
library(ggrepel)
```

🎬  Add labels to the significant genes with a large fold change:

```{r}

s30_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                                 "pink",
                                 "gray30",
                                 "deeppink")) +
  geom_text_repel(data = s30_results |> 
                    filter(bigfc == TRUE, sig == TRUE),
                  aes(label = xenbase_gene_symbol),
                  size = 3,
                  max.overlaps = 50) +
  theme_classic() +
  theme(legend.position = "none")

```
Notice that I have used `filter()` label only the genes that are both 
significant and have a large fold change. In systems you are familiar with, 
this labelling is very informative and can help you quickly identify common
themes.
Key to interpreting the volcano plot is to remember that positive fold 
changes means the gene is up-regulated in the FGF-treated samples and 
negative fold changes means the gene is down-regulated (i.e., higher 
in the control). This was determined by the order of the treatments in the
[contrast used in the DESeq2 analysis](../week-4/workshop.html#differential-expression-analysis-1)

If you do forget which way round you did the comparison, you can always 
examine the results dataframe to see which of the treatments seem to be
higher for the positive fold changes.

Please note that Betsy doesn't like graphs like this in the report!

When you have a gene of interest, you may wish to label it, and only it,
on the plot.  
This is done in the same way except that you filter the data to only
include the gene of interest. I have used and then use `geom_label_repel()` 
rather than `geom_text_repel()` to put the label in a box and nudged it's 
position to get a line connecting the point and the label. I have also 
increased the size of the point.


🎬 Add a label to one gene of interest (hoxb9.S) and :

```{r}
s30_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                                 "pink",
                                 "gray30",
                                 "deeppink")) +
  geom_label_repel(data = s30_results |> 
                    filter(xenbase_gene_symbol == "hoxb9.S"),
                  aes(label = xenbase_gene_symbol),
                  size = 4,
                  nudge_x = .5,
                  nudge_y = 1.5) +
  geom_point(data = s30_results |> 
                    filter(xenbase_gene_symbol == "hoxb9.S"),
                size = 3) +
  theme_classic() +
  theme(legend.position = "none")

```




## 🎄 *Arabidopsis*

We will add a column to the results dataframe that contains the 
-log~10~(padj). You could perform this transformation within the 
plot command without adding a column to the data if you prefer.

🎬  Add a column to the results dataframe that contains the -log~10~(padj):
```{r}
wild_results <- wild_results |> 
  mutate(log10_padj = -log10(padj)) 
```

🎬  Create a volcano plot of the results:
```{r}
wild_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(legend.position = "none")

```

Our dashed lines are at -log~10~(0.05) and log~2~(2) and log~2~(-2) to make
more clear which genes (points) are significantly different between the 
copper sufficient and deficient conditions samples and have a fold change of 
at least 2.

In most cases, people colour the points to show that the quadrants. I 
like to add columns to the dataframe to indicate if the gene is significant
and if the fold change is large and use those variables in the plot.

🎬  Add columns to the results dataframe to indicate if the gene is 
significant and if the fold change is large:
```{r}
wild_results <- wild_results |> 
  mutate(sig = padj <= 0.05,
         bigfc = abs(log2FoldChange) >= 2) 
```

The use of `abs()` (absolute) means genes with a fold change of at least 2 
in either direction will be considered to have a large fold change.

Now we can colour the points by these new columns. I use `interaction()` 
to create four categories: 

-   not significant and not large fold change (FF)
-   significant and not large fold change (TF)
-   not significant and large fold (FT)
-   significant and large fold change (TT)

And I use `scale_colour_manual()` to set the colours for these categories.

NOTE: there are no "significant and not large fold change (TF)" in this case.This means we do not need four colours. I have put the "pink" colour in the code but commented it out.


🎬  Create a volcano plot of the results with the points coloured by
significance and fold change:

```{r}
wild_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                                # "pink",
                                 "gray30",
                                 "deeppink")) +
  theme_classic() +
  theme(legend.position = "none")

```

For exploring the data, I like add labels to all the significant 
genes with a large fold change so I can very quickly identity them. The
`ggrepel` package has a function `geom_text_repel()` that is useful for 
adding labels so that they don't overlap.

🎬  Load the package:
```{r}
#| eval: false
library(ggrepel)
```

🎬  Add labels to the significant genes with a large fold change:

```{r}

wild_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                               #  "pink",
                                 "gray30",
                                 "deeppink")) +
  geom_text_repel(data = wild_results |> 
                    filter(bigfc == TRUE, sig == TRUE),
                  aes(label = external_gene_name),
                  size = 3,
                  max.overlaps = 50) +
  theme_classic() +
  theme(legend.position = "none")

```
Notice that I have used `filter()` label only the genes that are both 
significant and have a large fold change. In systems you are familiar with, 
this labelling is very informative and can help you quickly identify common
themes.
Key to interpreting the volcano plot is to remember that positive fold 
changes means the gene is up-regulated in the sufficient conditions and 
negative fold changes means the gene is down-regulated (i.e., higher 
in the deficient). This was determined by the order of the treatments in the
[contrast used in the DESeq2 analysis](../week-4/workshop.html#differential-expression-analysis-2)

If you do forget which way round you did the comparison, you can always 
examine the results dataframe to see which of the treatments seem to be
higher for the positive fold changes.

When you have a gene of interest, you may wish to label it, and only it,
on the plot. 
This is done in the same way except that you filter the data to only
include the gene of interest. I have used and then use `geom_label_repel()` 
rather than `geom_text_repel()` to put the label in a box and nudged it's 
position to get a line connecting the point and the label. I have also 
increased the size of the point.


🎬 Add a label to one gene of interest (hoxb9.S) and :

```{r}
wild_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                               #  "pink",
                                 "gray30",
                                 "deeppink")) +
  geom_label_repel(data = wild_results |> 
                    filter(external_gene_name == "FRO4"),
                  aes(label = external_gene_name),
                  size = 4,
                  nudge_x = .5,
                  nudge_y = 1.5) +
  geom_point(data = wild_results |> 
                    filter(external_gene_name == "FRO4"),
                size = 3) +
  theme_classic() +
  theme(legend.position = "none")

```

## 💉 *Leishmania*

We will add a column to the results dataframe that contains the 
-log~10~(padj). You could perform this transformation within the 
plot command without adding a column to the data if you prefer.

🎬  Add a column to the results dataframe that contains the -log~10~(padj):
```{r}
pro_meta_results <- pro_meta_results |> 
  mutate(log10_padj = -log10(padj)) 
```

🎬  Create a volcano plot of the results:
```{r}
pro_meta_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(legend.position = "none")

```

Our dashed lines are at -log~10~(0.05) and log~2~(2) and log~2~(-2) to make
more clear which genes (points) are significantly different between the 
life stages and have a fold change of at least 2. Whilst we have very many genes
that are significant, we have fewer that are significant and have a large 
fold change.

In most cases, people colour the points to show that the quadrants. I 
like to add columns to the dataframe to indicate if the gene is significant
and if the fold change is large and use those variables in the plot.

🎬  Add columns to the results dataframe to indicate if the gene is 
significant and if the fold change is large:
```{r}
pro_meta_results <- pro_meta_results |> 
  mutate(sig = padj <= 0.05,
         bigfc = abs(log2FoldChange) >= 2) 
```

The use of `abs()` (absolute) means genes with a fold change of at least 2 
in either direction will be considered to have a large fold change.

Now we can colour the points by these new columns. I use `interaction()` 
to create four categories: 

-   not significant and not large fold change (FF)
-   significant and not large fold change (TF)
-   not significant and large fold (FT)
-   significant and large fold change (TT)

And I use `scale_colour_manual()` to set the colours for these categories.

🎬  Create a volcano plot of the results with the points coloured by
significance and fold change:

```{r}
pro_meta_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                                 "pink",
                                 "gray30",
                                 "deeppink")) +
  theme_classic() +
  theme(legend.position = "none")

```

For exploring the data, I like add labels to all the significant 
genes with a large fold change so I can very quickly identity them. The
`ggrepel` package has a function `geom_text_repel()` that is useful for 
adding labels so that they don't overlap.

🎬  Load the package:
```{r}
#| eval: false
library(ggrepel)
```

🎬  Add labels to the significant genes with a large fold change:

```{r}

pro_meta_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                                 "pink",
                                 "gray30",
                                 "deeppink")) +
  geom_text_repel(data = pro_meta_results |> 
                    filter(bigfc == TRUE, sig == TRUE),
                  aes(label = description),
                  size = 3,
                  max.overlaps = 50) +
  theme_classic() +
  theme(legend.position = "none")

```
Notice that I have used `filter()` label only the genes that are both 
significant and have a large fold change. In systems you are familiar with, 
this labelling is very informative and can help you quickly identify common
themes. However, in this case, we do not have good annotation for the genes. 
We can label only with the gene id or the description. Many of the descriptions are 

🎬  Add labels to the significant genes with a large fold change only where description doesn't contain "hypothetical" or "unspecified :

```{r}

pro_meta_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                                 "pink",
                                 "gray30",
                                 "deeppink")) +
  geom_text_repel(data = pro_meta_results |> 
                    filter(bigfc == TRUE, sig == TRUE,
                           !str_detect(description, "hypothetical|unspecified")),
                  aes(label = description),
                  size = 3,
                  max.overlaps = 50) +
  theme_classic() +
  theme(legend.position = "none")

```

Key to interpreting the volcano plot is to remember that positive fold 
changes means the gene is up-regulated in the procyclic stage and 
negative fold changes means the gene is down-regulated (i.e., higher 
in the metacyclic). This was determined by the order of the treatments in the
[contrast used in the DESeq2 analysis](../week-4/workshop.html#differential-expression-analysis-3)

If you do forget which way round you did the comparison, you can always 
examine the results dataframe to see which of the treatments seem to be
higher for the positive fold changes.

When you have a gene of interest, you may wish to label it, and only it,
on the plot. 
This is done in the same way except that you filter the data to only
include the gene of interest. I have used and then use `geom_label_repel()` 
rather than `geom_text_repel()` to put the label in a box and nudged it's 
position to get a line connecting the point and the label. I have also 
increased the size of the point.


🎬 Add a label to one gene of interest (elongation factor 1-alpha) and :

```{r}
pro_meta_results |> 
  ggplot(aes(x = log2FoldChange, 
             y = log10_padj, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", 
                                 "pink",
                                 "gray30",
                                 "deeppink")) +
  geom_label_repel(data = pro_meta_results |> 
                    filter(description == "elongation factor 1-alpha"),
                  aes(label = description),
                  size = 4,
                  nudge_x = .5,
                  nudge_y = 1.5) +
  geom_point(data = pro_meta_results |> 
                    filter(description == "elongation factor 1-alpha"),
                size = 3) +
  theme_classic() +
  theme(legend.position = "none")

```


## 🐭 Stem cells

# Save your plots

Once you have finished designing your plots, you should save them 
using `ggsave()`. You will want to assign the plot to a variable and 
use code similar to this:	


```{r}
#| eval: false
ggsave("figures/my-informative-file-name.png",
       plot = vol,
       height = 4.5, 
       width = 4.5,
       units = "in",
       device = "png")
```

I recommend saving your figure in the approximate size it will appear in 
your report, that is, don't resize it in word/google docs. This because the 
font will then be an appropriate size for the report. For journals, we 
often have to creat figure files of very high resolution. You can do this
by increasing the `height` and `width` and then resizing the figure in
the document. however, this requires resizing the all font and lines in 
the figure.
I also recommend saving it as a png file as this is a lossless format. 

# 🤗 Look after future you!

🎬 Go through your script and tidy up. I would suggest restarting R and 
trying to run the full pipeline from start to finish. You might need to:

-   collect together library statements at the top of the script
-   remove code that you needed to start today but which wouldn't be
    needed running the script from the top (e.g., importing the results)
-   edit your comments for clarity
-   rename variables for consistency or clarity
-   remove house keeping or exploratory code
-   restyle code, add code section headers etc

# 🥳 Finished

Well Done!

# Independent study following the workshop

[Consolidate](study_after_workshop.qmd)

# The Code file

These contain all the code needed in the workshop even where it is not
visible on the webpage.

The [workshop.qmd](workshop.qmd) file is the file I use to compile the
practical. Qmd stands for Quarto markdown. It allows code and ordinary
text to be interleaved to produce well-formatted reports including
webpages. Right-click on the link and choose Save-As to download. You
will be able to open the Qmd file in RStudio. Alternatively, [View in
Browser](https://github.com/3mmaRand/BIO00088H-data/blob/main/transcriptomics/week-5/workshop.qmd).
Coding and thinking answers are marked with `#---CODING ANSWER---` and
`#---THINKING ANSWER---`

Pages made with R [@R-core], Quarto [@Allaire_Quarto_2024], `knitr` [@knitr1; @knitr2; @knitr3], `kableExtra` [@kableExtra]

# References
