---
title: "Untitled"
---

## ğŸ­ Stem cells

### Import

Import the data for the HSPC and the lthscenitor cells.

```{r}
library(tidyverse)
library(conflicted)
library(scran)

conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
conflicts_prefer(GenomicRanges::setdiff)

```

```{r}
# ğŸ­ import the hspc and lthsc data
hspc  <- read_csv("data-raw/secretome_hspc.csv")

lthsc  <- read_csv("data-raw/secretome_lthsc.csv")
```

We will need to combine the two sets of columns (datasets) so we can
compare the two stages. We will join them using `ensembl_gene_id` to
match the rows. The column names differ so we don't need to worry about
renaming any of them.

ğŸ¬ Combine the two datasets by `ensembl_gene_id` and save the result as
`hspc_lthsc`.

```{r}
#  combine the two datasets
hspc_lthsc <- hspc |>
  left_join(lthsc, 
            by = "ensembl_gene_id")
```

ğŸ¬ Summarise all the cells:

```{r}
hspc_lthsc_summary_cell <- hspc_lthsc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(cell) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_above_zero = sum(expr > 0))
```

ğŸ¬ View the `hspc_lthsc_summary_cell` dataframe (click on it in the
environment).

Notice that: - a minimum value of 0 appears in all 1499 cells - the
lower quartiles are all zero and so are many of the medians - there are
no cells with above 0 expression in all `r nrow(hspc)` of the gene
subset - the highest number of genes expressed is
`r max(hspc_lthsc_summary_cell$n_above_zero)`, the lowest is
`r min(hspc_lthsc_summary_cell$n_above_zero)`

In short, there are quite a lot of zeros.

To get a better understanding of the distribution of expressions in
cells we can create a ggplot using the pointrange geom. Pointrange puts
a dot at the mean and a line between a minimum and a maximum such as +/-
one standard deviation. Not unlike a boxplot, but when you need the
boxes too be very narrow!

ğŸ¬ Create a pointrange plot.

```{r}
hspc_lthsc_summary_cell |> 
  ggplot(aes(x = cell, y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, 
                      ymax = mean + sd ),
                  size = 0.1)
```

You will need to use the Zoom button to pop the plot window out so you
can make it as wide as possible

The things to notice are:

-   the average expression in cells is similar for all cells. This is
    good to know - if some cells had much lower expression perhaps there
    is something wrong with them, or their sequencing, and they should
    be excluded.
-   the distributions are roughly similar in width too

The default order of `cell` is alphabetical. It can be easier to judge
if there are unusual cells if we order the lines by the size of the
mean.

ğŸ¬ Order a pointrange plot with `reorder(variable_to_order, order_by)`.

```{r}
hspc_lthsc_summary_cell |> 
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, 
                      ymax = mean + sd ),
                  size = 0.1)
```

`reorder()` arranges `cell` in increasing size of `mean`

As we thought, the distributions are similar across cells - there are
not any cells that are obviously different from the others (only
incrementally).

### Distribution of values across the genes

We will use the same approach to summarise the genes.

ğŸ¬ Summarise the expression for each gene and save the result as
`hspc_lthsc_summary_gene`. Include the same columns as we had in the by
cell summary (`hspc_lthsc_summary_cell`) and an additional column,
`total` for the total expression for each gene.

```{r}

# you need to group by `ensembl_gene_id` rather than `cell`
# sum(expr) will find the total expression in a gene
hspc_lthsc_summary_gene <- hspc_lthsc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(ensembl_gene_id) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_above_zero = sum(expr > 0))
```

ğŸ¬ View the `hspc_lthsc_summary_gene` dataframe. Remember these are
normalised and logged (base 2) so we should not see very large values.

Notice that:

-   some genes are expressed in every cell, and many are expressed in
    most cells
-   quite a few genes are zero in many cells. This this matters less
    when we have many cells (samples) than when we have few samples.
-   no genes have zeros in every cell - the lowest number of cells is is
    `r min(hspc_lthsc_summary_gene$n_above_zero)`

It is again helpful to plot the ordered mean expression with pointrange
to get an overview.

ğŸ¬ Plot the logged mean counts for each gene in order of size using
`geom_pointrange()`:

```{r}
hspc_lthsc_summary_gene |> 
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, 
                      ymax = mean + sd),
                  size = 0.1)


```

Note that the variability between genes (average expression between
`r min(hspc_lthsc_summary_gene$mean) |> round(4)` and
`r max(hspc_lthsc_summary_gene$mean) |> round(4)`) is greater than
between cells (average expression between
`r min(hspc_lthsc_summary_cell$mean) |> round(4)` and
`r max(hspc_lthsc_summary_cell$mean) |> round(4)`) which is just what we
would expect.

Now go to [Filtering for QC](#stem-cells-filterqc). \## ğŸ­ Stem cells
{#stem-cells-differential}

These are the steps we will take

1.  Find the genes that are expressed in only one cell type (the lthsc
    or the hspc).
2.  Prepare the data for differential expression analysis with the
    **`scran`** package.
3.  Do differential expression analysis on the genes using the
    **`scran`** package. This needs to be done on the logged normalised
    counts.

### 1. Genes expressed in one cell type

The genes expressed in only cell type are those with zeros in all the
cells of the other type. We can find these by summing the expression
values for each gene across the cells of one type and filtering for
those that are zero.

To do row wise aggregates such as the sum across rows we can use the
`rowwise()` function. `c_across()` allows us to use the colon notation
to select columns. This is very useful when you have a lot of columns
because it would be annoying to have to list all of them.
`HSPC_001:HSPC_852` means all the columns from `HSPC_001` to `HSPC_852`.

ğŸ¬ Find the genes expressed only in lthscenitor cells (*i.e.*, those
that are 0 in every HSPC cell):

```{r}
hspc_lthsc |> 
  rowwise() |> 
  filter(sum(c_across(HSPC_001:HSPC_852)) == 0)

```

We already know from last week's work that there are no genes that are
zero across all the cells (both types). If we did not know that, we
would need to add `|> filter(sum(c_across(lthsc_001:lthsc_852)) != 0)`

meaning zero in all the HSPC but not zero in all the lthsc

â“ How many genes are expressed only in the lthscenitor cells only

<!-- #---THINKING ANSWER--- -->

<!-- No genes are expressed only in the lthsc cells. -->

ğŸ¬ Now you find any genes that are expressed only in the lthsc cells.

```{r}

hspc_lthsc |> 
  rowwise() |> 
  filter(sum(c_across(LT.HSC_001:LT.HSC_215)) == 0)

```

â“ How many genes are expressed only in the HSPC cells?

<!-- #---THINKING ANSWER--- -->

<!-- No genes genes are expressed only in the HSPC cells? -->

â“ Do the results make sense to you in light of what you know about the
biology?

<!-- #---THINKING ANSWER--- -->

<!-- I'm not sure what to expect here. However, when there are many  -->

<!-- "replicates" it is less likely that a gene will be expressed  -->

<!-- in only one group. It's more likely that a gene will be -->

<!-- expressed in both groups but at different levels. -->

<!-- Domain expertise is important when analysing data so  -->

<!-- discuss your results with Jillian and your group. -->

ğŸ¬ Write all the genes that are expressed one cell type only to file
(saved in `results`)

```{r}
#| echo: false
#| eval: false
#---CODING ANSWER---
# If we had any genes expressed in only one cell type we would write 
# them to a file like this. 
write_csv(hspc_lthsc_hspc_only, "results/hspc_lthsc_hspc_only.csv")
write_csv(hspc_lthsc_lthsc_only, "results/hspc_lthsc_lthsc_only.csv")
```

### 2. Prepare the data for analysis with **`scran`**

**`scran`** can use a matrix or a dataframe of counts but these must be
log normalised counts. If using a dataframe, the columns must only
contain the expression values (not the gene ids). The rows can be named
to retain the gene ids.

`hspc_lthsc` is a dataframe so we will use the ensembl gene ids to name
the rows and remove the gene ids from the dataframe.

ğŸ¬ Add the gene ids as the row names:

```{r}
hspc_lthsc <- hspc_lthsc |>
  column_to_rownames("ensembl_gene_id")

```

Like **`DESeq2`**, **`scran`** needs metadata to define which columns
were in which group. Instead of having this is a file, we will create a
vector that indicates which column belongs to which cell type.

ğŸ¬ Create a vector that indicates which column belongs to which cell
type:

```{r}
n_hspc <- 701
n_lthsc <- 155

cell_type <- rep(c("hspc","lthsc"), 
                 times = c(n_hspc, n_lthsc))
```

The number of times each cell type is repeated is the number of cells of
that type. Do check that the length of the `cell_type` vector is the
same as the number of columns in the `hspc_lthsc` dataframe.

### 3. Differential expression analysis

ğŸ¬ Load the **`scran`** package:

```{r}
#| echo: false
library(scran)
```

Differential expression is carried out with the `findMarkers()`
function. It takes two arguments. The first argument is the dataframe
containing the data and the second argument is the vector indicating
which columns are in which cell type. Make sure that the order of the
cell types in the vector is appropriate for the order of the columns in
the dataframe.

ğŸ¬ Run the differential expression analysis:

```{r}
results_hspc_lthsc <- findMarkers(hspc_lthsc, 
                             cell_type)
```

The output is a list object which, rather unnecessarily, includes two
dataframes. This is not really necessary as the results are the same
except for the fold change having a different sign.

-   The dataframe `results_hspc_lthsc$lthsc` is log lthsc - log hspc
    (*i.e.*,lthsc/HSPC). This means:

    -   Positive fold change: lthsc is higher than hspc
    -   Negative fold change: hspc is higher than lthsc

```{r}
#| echo: false
data.frame(results_hspc_lthsc$lthsc, 
           ensembl_gene_id = row.names(results_hspc_lthsc$lthsc)) |>
  head() |> 
  knitr::kable(cap = "The results_hspc_lthsc$lthsc dataframe")
```

-   The dataframe `results_hspc_lthsc$hspc` is log hspc - log lthsc
    (*i.e.*, HSPC/lthsc). This means:

    -   Positive fold change: hspc is higher than lthsc
    -   Negative fold change: lthsc is higher than hspc

```{r}
#| echo: false
data.frame(results_hspc_lthsc$hspc, 
           ensembl_gene_id = row.names(results_hspc_lthsc$hspc)) |>
  head() |> 
  knitr::kable(cap = "The results_hspc_lthsc$hspc dataframe. Notice the sign of the fold change is the other way")
```

We only need one of these results dataframes and we will use the `lthsc`
one. It does not matter which one you use but you do need keep the
direction of the foldchange in mind when interpreting the results.

Notice that the dataframes are ordered by significance rather than the
original gene order.

It is useful to have the normalised counts and the statistical results
in one dataframe to which we will add the gene information from Ensembl.
Having all the information together will make it easier to interpret the
results and select genes of interest. We will need to extract the
results from the list object, add the gene ids and then join with the
normalised counts.

ğŸ¬ Extract the results dataframe from the list object and add the gene
ids as a column:

```{r}
hspc_lthsc_results <- data.frame(results_hspc_lthsc$lthsc, 
                                ensembl_gene_id = row.names(results_hspc_lthsc$lthsc)) 
```

ğŸ¬ Return the ensembl gene ids as a column to the normalised counts:

```{r}
hspc_lthsc <- hspc_lthsc |>
  rownames_to_column(var = "ensembl_gene_id")

```

ğŸ¬ Merge the results dataframe with the normalised counts:

```{r}
# merge the results with the normalised counts
hspc_lthsc_results <- hspc_lthsc_results |>
  left_join(hspc_lthsc, by = "ensembl_gene_id")

```

Now go to [Add gene information](#stem-add-info).

## ğŸ­ Stem cells {#stem-cells-add-info}

[Ensembl](https://www.ensembl.org/index.html) [@martin2023;
@birney2004]is a bioinformatics project to organise all the biological
information around the sequences of large genomes. The are a large
number of databases but
[BioMart](https://www.ensembl.org/info/data/biomart/index.html)
[@smedley2009] provides a consistent interface to the material. There
are web-based tools to use these but the R package **`biomaRt`**
[@biomaRt1; @biomaRt2] gives you lthscrammatic access making it easier
to integrate information into R dataframes

ğŸ¬ Load the **`biomaRt`** [@biomaRt1; @biomaRt2] package:

```{r}
#| eval: false
library(biomaRt)
```

ğŸ¬ Connect to the mouse database

```{r}
# Connect to the mouse database

ensembl <- useMart(biomart = "ensembl", 
                   dataset = "mmusculus_gene_ensembl")
```

ğŸ¬ See information we can retrieve:

```{r}
#| eval: false
# See what information we can retrieve
listAttributes(mart = ensembl) |> View()

```

There are many (\~3000!) possible bits of information (attributes) that
can be obtained.

We use the `getBM()` function to retrieve information from the database.
The `filters` argument is used to specified what kind of identifier we
are supplying in `values` to retrieve information. The `attributes`
argument is used to select the information we want to retrieve. The
`values` argument is used to specify the identifiers. The mart argument
is used to specify the connection we created.

ğŸ¬ Get the the gene name and a description. We also retrieve the gene id
so we can later join the information with the results:

```{r}
gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = hspc_lthsc_results$ensembl_gene_id,
                   mart = ensembl)
```

You should view the resulting dataframe to see what information is
available. You can use `glimpse()` or `View()`. Notice the dataframe
returned only has `r nrow(gene_info)` rows - one of the ids does not
have information.

ğŸ¬ Merge the gene information with the results:

```{r}
# join the gene info with the results
hspc_lthsc_results <- hspc_lthsc_results |> 
  left_join(gene_info, by = "ensembl_gene_id")
```

ğŸ¬ Save the results to a file:

```{r}
write_csv(hspc_lthsc_results, file = "results/hspc_lthsc_results.csv")
```
