---
title: "Workshop"
subtitle: "Omics Extra: Tips for different cell classification"
author: "Emma Rand"
toc: true
toc-depth: 4
toc-location: right
execute:
  echo: true
  include: true
  error: true
bibliography: ../../references.bib
editor: 
  markdown: 
    wrap: 72
---

# Introduction

This is a continuation of the workshops so works with `prog` and `hspc` only.

ğŸ¬ Open ğŸ­ `mice-88H` Project and the `hspc-prog.R` script.


ğŸ¬ Load **`tidyverse`** [@tidyverse] and **`conflicted`** [@conflicted].
You most likely have this code at the top of `hspc-prog.R` already.

```{r}
library(tidyverse)
library(conflicted)
```

```         
â”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€
âœ” dplyr     1.1.3     âœ” readr     2.1.4
âœ” forcats   1.0.0     âœ” stringr   1.5.0
âœ” ggplot2   3.4.3     âœ” tibble    3.2.1
âœ” lubridate 1.9.3     âœ” tidyr     1.3.0
âœ” purrr     1.0.2     
â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
âœ– dplyr::filter() masks stats::filter()
âœ– dplyr::lag()    masks stats::lag()
â„¹ Use the conflicted package to force all conflicts to become errors
```

ğŸ¬ Use the **`dplyr`** version of `filter()` by default:

```{r}
conflict_prefer("filter", "dplyr")
```


# ğŸ­ Analysis


## Import

We need to import the normalised counts. 

ğŸ¬ Import the normalised counts for the Prog and HSPC cell types. I used
the names `prog` and `hspc` for the dataframes.

```{r}
# import the normalised counts
prog <- read_csv("data-raw/surfaceome_prog.csv")
hspc <- read_csv("data-raw/surfaceome_hspc.csv")

```

ğŸ¬ Combine the two dataframes (minus one set of gene ids) into one
dataframe called prog_hspc:

```{r}
# combine into one dataframe dropping one of the gene id columns
prog_hspc <- bind_cols(prog, hspc[-1])
```

I filtered the cell types data so it contained only those cells present in the expression data: [er_cell_types.csv](er_cell_types.csv)

ğŸ¬ Import cell types

```{r}

cell_types <- read_csv("er_cell_types.csv")
```
 The alternatives cell types are:
```{r}
colnames(cell_types)
```
 


Notice the organisation. The cell names are in rows, there are 1654 of them which is 155 + 798 + 701. The columns are the alternative (to hspc and prog etc) cell types. The 0 or 1 indicates if the cell is of that type or not. Note that the alternative cell types are *not* mutually exclusive. For example, HSPC_001 is a MPP_broad and a STHSC_broad

Here we need to further filter the cell types data so it contained only those cells present in prog and hspc
```{r}
#names of cells
all_cells <- c(colnames(hspc[-1]), colnames(prog[-1]))

# filter the cell types
cell_types <- cell_types |> 
  filter(cell %in% all_cells)
```

Now you have 1499 alternative names for the 1499 columns in the prog_hspc dataframe (the 1500th is the gene)


## View the relationship between cells using PCA

We have 280 genes in our dataset. PCA will allow us to plot our cells in the "gene expression" space so we can see if Prog cells cluster together and HSPC cells cluster together as we would expect. We do this on the log~2~ transformed normalised counts. 

Our data have genes in rows and samples in columns which is a common organisation for gene expression data. However, PCA expects cells in rows and genes, the variables, in columns. We can transpose the data to get it in the correct format.

ğŸ¬ Transpose the log~2~ transformed normalised counts:
```{r}
prog_hspc_trans <- prog_hspc_results |> 
  dplyr::select(starts_with(c("Prog_", "HSPC_"))) |>
  t() |> 
  data.frame()
```

We have used the `select()` function to select all the columns that start with `Prog_` or  `HSPC_`. We then use the `t()` function to transpose the dataframe. We then convert the resulting matrix to a dataframe using `data.frame()`. If you view that dataframe you'll see it has default column name which we can fix using `colnames()` to set the column names to the gene ids.

ğŸ¬ Set the column names to the gene ids:

```{r}
colnames(prog_hspc_trans) <- prog_hspc_results$ensembl_gene_id
```

perform PCA using standard functions

```{r}
pca <- prog_hspc_trans |>
  prcomp(rank. = 15) 
```

The `rank.` argument tells `prcomp()` to only calculate the first 15 principal components. This is useful for visualisation as we can only plot in 2 or 3 dimensions. We can see the results of the PCA by viewing the `summary()` of the `pca` object.


```{r}
summary(pca)
```

The Proportion of Variance tells us how much of the variance is explained by each component. We can see that the first component explains 0.1099 of the variance, the second 0.04874, and the third 0.2498. Together the first three components explain 18% of the total variance in the data. Plotting PC1 against PC2 will capture about 16% of the variance. This is not that high but it likely better than we would get plotting any two genes against each other.
To plot the PC1 against PC2 we will need to extract the PC1 and PC2
score from the pca object and add labels for the cells.


ğŸ¬ Create a dataframe of the PC1 and PC2 scores which are in `pca$x` and add the cell ids:
```{r}
pca_labelled <- data.frame(pca$x,
                           cell_id = row.names(prog_hspc_trans))
```

It will be helpful to add a column for the cell type so we can label points. One way to do this is to extract the information in the cell_id column into two columns. 

ğŸ¬ Extract the cell type and cell number from the `cell_id` column (keeping the `cell_id` column):
```{r}
pca_labelled <- pca_labelled |> 
  extract(cell_id, 
          remove = FALSE,
          c("cell_type", "cell_number"),
          "([a-zA-Z]{4})_([0-9]{3})")
```

`"([a-zA-Z]{4})_([0-9]{3})"` is a [regular expression](https://en.wikipedia.org/wiki/Regular_expression) - or regex. `[a-zA-Z]` means any lower or upper case letter, `{4}` means 4 of them, and `[0-9]` means any number, `{3}` means 3 of them. The brackets around the two parts of the regex mean we want to extract those parts. The first part goes into `cell_type` and the second part goes into `cell_number`. The `_` between the two patterns matches the underscore and the fact it isn't in a bracket means we don't want to keep it.

We can now plot the PC1 and PC2 scores.


ğŸ¬ Plot PC1 against PC2 and colour the points by cell type:
```{r}
pca <- pca_labelled |> 
  ggplot(aes(x = PC1, y = PC2, 
             colour = cell_type)) +
  geom_point(alpha = 0.4) +
  scale_colour_viridis_d(end = 0.8, begin = 0.15,
                         name = "Cell type") +
  theme_classic()
pca
```

Fairly good separation of cell types but plenty of overlap

ğŸ¬ Save the plot to file:
```{r}
ggsave("figures/prog_hspc-pca.png",
       plot = pca,
       height = 3, 
       width = 4,
       units = "in",
       device = "png")
```



## Visualise the expression of the most significant genes using a heatmap

A heatmap is a common way to visualise gene expression data. Often people will create heatmaps with thousands of genes but it can be more informative to use a subset along with clustering methods. We will use the genes which are significant at the 0.01 level. 

We are going to create an interactive heatmap with the **`heatmaply`** [@heatmaply] package. **`heatmaply`** takes a matrix as input so we need to convert a dataframe of the log~2~ values to a matrix. We will also set the rownames to the gene names.


ğŸ¬ Convert a dataframe of the log~2~ values to a matrix. I have used `sample()` to select 70 random columns so the heatmap is generated quickly:

```{r}
mat <- prog_hspc_results_sig0.01 |> 
  dplyr::select(starts_with(c("Prog", "HSPC"))) |>
  dplyr::select(sample(1:1499, size = 70)) |>
  as.matrix()
```


ğŸ¬ Set the row names to the gene names:

```{r}
rownames(mat) <- prog_hspc_results_sig0.01$external_gene_name
```

You might want to view the matrix by clicking on it in the environment pane. 

ğŸ¬ Load the **`heatmaply`** package:
```{r}
library(heatmaply)
```

We need to tell the clustering algorithm how many clusters to create. We will set the number of clusters for the cell types to be 2 and the number of clusters for the genes to be the same since it makes sense to see what clusters of genes correlate with the cell types.

```{r}
n_cell_clusters <- 2
n_gene_clusters <- 2
```


ğŸ¬ Create the heatmap:

```{r}

heatmaply(mat, 
          scale = "row",
          k_col = n_cell_clusters,
          k_row = n_gene_clusters,
          fontsize_row = 7, fontsize_col = 10,
          labCol = colnames(mat),
          labRow = rownames(mat),
          heatmap_layers = theme(axis.line = element_blank()))
```

It will take a minute to run and display. On the vertical axis are genes which are differentially expressed at the 0.01 level. On the horizontal axis are cells. We can see that cells of the same type don't cluster that well together. We can also see two clusters of genes but the pattern of gene is not as clear as it was for the frogs and the correspondence with the cell clusters is not as strong.

The heatmap will open in the viewer pane (rather than the plot pane) because it is html. You can "Show in a new window" to see it in a larger format. You can also zoom in and out and pan around the heatmap and download it as a png. You might feel the colour bars is not adding much to the plot. You can remove it by setting `hide_colorbar = TRUE,` in the `heatmaply()` function. 

Using all the cells is worth doing but it will take a while to generate the heatmap and then show in the viewer so do it sometime when you're ready for a coffee break. 

## Visualise all the results with a volcano plot

colour the points if FDR \< 0.05 and prog_hspc_results \> 1

```{r}
library(ggrepel)
```

```{r}

prog_hspc_results <- prog_hspc_results |> 
  mutate(log10_FDR = -log10(FDR),
         sig = FDR < 0.05,
         bigfc = abs(summary.logFC) >= 2) 
```

```{r}
vol <- prog_hspc_results |> 
  ggplot(aes(x = summary.logFC, 
             y = log10_FDR, 
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 2, 
             linetype = "dashed") +
  geom_vline(xintercept = -2, 
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray",
                                 "pink",
                                 "deeppink")) +
  geom_text_repel(data = subset(prog_hspc_results, 
                                bigfc & sig),
                  aes(label = external_gene_name),
                  size = 3,
                  max.overlaps = 50) +
  theme_classic() +
  theme(legend.position = "none")
vol
```

```{r}
ggsave("figures/prog-hspc-volcano.png",
       plot = vol,
       height = 4.5, 
       width = 4.5,
       units = "in",
       device = "png")
```

<!-- The dataframe `res_prog_hspc$prog` is log prog - log hspc -->

<!-- (i.e.,Prog/HSPC). This means - Positive fold change: prog is higher than -->

<!-- hspc - Negative fold change: hspc is higher than prog -->

<!-- The dataframe `res_prog_hspc$hspc` is log hspc - log prog (i.e., -->

<!-- HSPC/Prog). . This means - Positive fold change: hspc is higher than -->

<!-- prog - Negative fold change: prog is higher than hspc -->

# ğŸ¤— Look after future you!

ğŸ¬ Go through your script (`cont-fgf-s30.R` or `hspc-prog.R`) and tidy
up. I would suggest restarting R and trying to run the full pipeline
from start to finish. You might need to :

-   collect together library statements at the top of the script
-   remove code that you needed to start today but which wouldn't be
    needed running the script from the top (e.g., importing)
-   edit your comments for clarity
-   rename variables for consistency or clarity
-   remove house keeping or exploratory code
-   restyle code, add code section headers etc

# ğŸ¥³ Finished

Well Done!

# Independent study following the workshop

[Consolidate](study_after_workshop.qmd)

# The Code file

These contain all the code needed in the workshop even where it is not
visible on the webpage.

The [workshop.qmd](workshop.qmd) file is the file I use to compile the
practical. Qmd stands for Quarto markdown. It allows code and ordinary
text to be interleaved to produce well-formatted reports including
webpages. Right-click on the link and choose Save-As to download. You
will be able to open the Qmd file in RStudio. Alternatively, [View in
Browser](https://github.com/3mmaRand/BIO00088H-data/blob/main/omics/week-4/workshop.qmd).
Coding and thinking answers are marked with `#---CODING ANSWER---` and
`#---THINKING ANSWER---`

Pages made with R [@R-core], Quarto [@allaire2022], `knitr` [@knitr],
`kableExtra` [@kableExtra]

# References
